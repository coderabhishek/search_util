Show how to compute the length of an LCS using only 2 · min(m, n) entries in the c table plus
O(1) additional space. Then show how to do this using min(m, n) entries plus O(1) additional
space.

Exercises 15.4-5
Give an O(n2)-time algorithm to find the longest monotonically increasing subsequence of a
sequence of n numbers.

Exercises 15.4-6: ⋆
Give an O(n lg n)-time algorithm to find the longest monotonically increasing sub-sequence
of a sequence of n numbers. (Hint: Observe that the last element of a candidate subsequence
of length i is at least as large as the last element of a candidate subsequence of length i - 1.
Maintain candidate subsequences by linking them through the input sequence.)

15.5 Optimal binary search trees
Suppose that we are designing a program to translate text from English to French. For each
occurrence of each English word in the text, we need to look up its French equivalent. One
way to perform these lookup operations is to build a binary search tree with n English words
as keys and French equivalents as satellite data. Because we will search the tree for each
individual word in the text, we want the total time spent searching to be as low as possible.
We could ensure an O(lg n) search time per occurrence by using a red-black tree or any other
balanced binary search tree. Words appear with different frequencies, however, and it may be
the case that a frequently used word such as "the" appears far from the root while a rarely
used word such as "mycophagist" appears near the root. Such an organization would slow
down the translation, since the number of nodes visited when searching for a key in a binary
search tree is one plus the depth of the node containing the key. We want words that occur
frequently in the text to be placed nearer the root.[5] Moreover, there may be words in the text
for which there is no French translation, and such words might not appear in the binary search
tree at all. How do we organize a binary search tree so as to minimize the number of nodes
visited in all searches, given that we know how often each word occurs?
What we need is known as an optimal binary search tree. Formally, we are given a sequence
K = k1, k2, ..., kn of n distinct keys in sorted order (so that k1 < k2 < ··· < kn), and we wish to
build a binary search tree from these keys. For each key ki, we have a probability pi that a
search will be for ki. Some searches may be for values not in K, and so we also have n + 1
"dummy keys" d0, d1, d2, ..., dn representing values not in K. In particular, d0 represents all
values less than k1, dn represents all values greater than kn, and for i = 1, 2, ..., n -1, the
dummy key di represents all values between ki and ki+1. For each dummy key di, we have a
probability qi that a search will correspond to di. Figure 15.7 shows two binary search trees
for a set of n = 5 keys. Each key ki is an internal node, and each dummy key di is a leaf. Every

