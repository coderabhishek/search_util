In Exercise 13.3-2, you found the red-black tree that results from successively inserting the
keys 41, 38, 31, 12, 19, 8 into an initially empty tree. Now show the red-black trees that result
from the successive deletion of the keys in the order 8, 12, 19, 31, 38, 41.

Exercises 13.4-4
In which lines of the code for RB-DELETE-FIXUP might we examine or modify the sentinel
nil[T]?

Exercises 13.4-5
In each of the cases of Figure 13.7, give the count of black nodes from the root of the subtree
shown to each of the subtrees α, β, ..., ζ, and verify that each count remains the same after the
transformation. When a node has a color attribute c or c′, use the notation count(c) or
count(c′) symbolically in your count.

Exercises 13.4-6
Professors Skelton and Baron are concerned that at the start of case 1 of RB-DELETEFIXUP, the node p[x] might not be black. If the professors are correct, then lines 5–6 are
wrong. Show that p[x] must be black at the start of case 1, so that the professors have nothing
to worry about.

Exercises 13.4-7
Suppose that a node x is inserted into a red-black tree with RB-INSERT and then immediately
deleted with RB-DELETE. Is the resulting red-black tree the same as the initial red-black
tree? Justify your answer.

Problems 13-1: Persistent dynamic sets
During the course of an algorithm, we sometimes find that we need to maintain past versions
of a dynamic set as it is updated. Such a set is called persistent. One way to implement a
persistent set is to copy the entire set whenever it is modified, but this approach can slow
down a program and also consume much space. Sometimes, we can do much better.

