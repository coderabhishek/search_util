We must be very careful in deciding on the distribution of inputs. For some problems, it is
reasonable to assume something about the set of all possible inputs, and we can use
probabilistic analysis as a technique for designing an efficient algorithm and as a means for
gaining insight into a problem. For other problems, we cannot describe a reasonable input
distribution, and in these cases we cannot use probabilistic analysis.
For the hiring problem, we can assume that the applicants come in a random order. What does
that mean for this problem? We assume that we can compare any two candidates and decide
which one is better qualified; that is, there is a total order on the candidates. (See Appendix B
for the definition of a total order.) We can therefore rank each candidate with a unique
number from 1 through n, using rank(i) to denote the rank of applicant i, and adopt the
convention that a higher rank corresponds to a better qualified applicant. The ordered list
<rank(1), rank(2), ..., rank(n)> is a permutation of the list <1, 2, ..., n>. Saying that the
applicants come in a random order is equivalent to saying that this list of ranks is equally
likely to be any one of the n! permutations of the numbers 1 through n. Alternatively, we say
that the ranks form a uniform random permutation; that is, each of the possible n!
permutations appears with equal probability.
Section 5.2 contains a probabilistic analysis of the hiring problem.
Randomized algorithms
In order to use probabilistic analysis, we need to know something about the distribution on the
inputs. In many cases, we know very little about the input distribution. Even if we do know
something about the distribution, we may not be able to model this knowledge
computationally. Yet we often can use probability and randomness as a tool for algorithm
design and analysis, by making the behavior of part of the algorithm random.
In the hiring problem, it may seem as if the candidates are being presented to us in a random
order, but we have no way of knowing whether or not they really are. Thus, in order to
develop a randomized algorithm for the hiring problem, we must have greater control over the
order in which we interview the candidates. We will, therefore, change the model slightly. We
will say that the employment agency has n candidates, and they send us a list of the
candidates in advance. On each day, we choose, randomly, which candidate to interview.
Although we know nothing about the candidates (besides their names), we have made a
significant change. Instead of relying on a guess that the candidates will come to us in a
random order, we have instead gained control of the process and enforced a random order.
More generally, we call an algorithm randomized if its behavior is determined not only by its
input but also by values produced by a random-number generator. We shall assume that we
have at our disposal a random-number generator RANDOM. A call to RANDOM(a, b)
returns an integer between a and b, inclusive, with each such integer being equally likely. For
example, RANDOM(0, 1) produces 0 with probability 1/2, and it produces 1 with probability
1/2. A call to RANDOM(3, 7) returns either 3, 4, 5, 6 or 7, each with probability 1/5. Each
integer returned by RANDOM is independent of the integers returned on previous calls. You
may imagine RANDOM as rolling a (b - a + 1)-sided die to obtain its output. (In practice,
most programming environments offer a pseudorandom-number generator: a deterministic
algorithm returning numbers that "look" statistically random.)a
Exercises 5.1-1

