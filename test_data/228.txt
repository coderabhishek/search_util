6
7
8
9
10
11
12
13

then x ← left[x]
else x ← right[x]
p[z] ← y
if y = NIL
then root[T] ← z
else if key[z] < key[y]
then left[y] ← z
else right[y] ← z

⊹ Tree T was empty

Figure 12.3 shows how TREE-INSERT works. Just like the procedures TREE-SEARCH and
ITERATIVE-TREE-SEARCH, TREE-INSERT begins at the root of the tree and traces a path
downward. The pointer x traces the path, and the pointer y is maintained as the parent of x.
After initialization, the while loop in lines 3–7 causes these two pointers to move down the
tree, going left or right depending on the comparison of key[z] with key[x], until x is set to
NIL. This NIL occupies the position where we wish to place the input item z. Lines 8–13 set
the pointers that cause z to be inserted.

Figure 12.3: Inserting an item with key 13 into a binary search tree. Lightly shaded nodes
indicate the path from the root down to the position where the item is inserted. The dashed
line indicates the link in the tree that is added to insert the item.
Like the other primitive operations on search trees, the procedure TREE-INSERT runs in
O(h) time on a tree of height h.
Deletion
The procedure for deleting a given node z from a binary search tree takes as an argument a
pointer to z. The procedure considers the three cases shown in Figure 12.4. If z has no
children, we modify its parent p[z] to replace z with NIL as its child. If the node has only a
single child, we "splice out" z by making a new link between its child and its parent. Finally,
if the node has two children, we splice out z's successor y, which has no left child (see
Exercise 12.2-5) and replace z's key and satellite data with y's key and satellite data.

