3
4

else top[S] ← top[S] - 1
return S[top[S] + 1]

Figure 10.1 shows the effects of the modifying operations PUSH and POP. Each of the three
stack operations takes O(1) time.
Queues
We call the INSERT operation on a queue ENQUEUE, and we call the DELETE operation
DEQUEUE; like the stack operation POP, DEQUEUE takes no element argument. The FIFO
property of a queue causes it to operate like a line of people in the registrar's office. The
queue has a head and a tail. When an element is enqueued, it takes its place at the tail of the
queue, just as a newly arriving student takes a place at the end of the line. The element
dequeued is always the one at the head of the queue, like the student at the head of the line
who has waited the longest. (Fortunately, we don't have to worry about computational
elements cutting into line.)
Figure 10.2 shows one way to implement a queue of at most n - 1 elements using an array Q[1
n]. The queue has an attribute head[Q] that indexes, or points to, its head. The attribute
tail[Q] indexes the next location at which a newly arriving element will be inserted into the
queue. The elements in the queue are in locations head[Q], head[Q] +1,..., tail[Q] - 1, where
we "wrap around" in the sense that location 1 immediately follows location n in a circular
order. When head[Q] = tail[Q], the queue is empty. Initially, we have head[Q] = tail[Q] = 1.
When the queue is empty, an attempt to dequeue an element causes the queue to underflow.
When head[Q] = tail[Q] + 1, the queue is full, and an attempt to enqueue an element causes
the queue to overflow.

Figure 10.2: A queue implemented using an array Q[1 12]. Queue elements appear only in
the lightly shaded positions. (a) The queue has 5 elements, in locations Q[7 11]. (b) The
configuration of the queue after the calls ENQUEUE(Q, 17), ENQUEUE(Q, 3), and
ENQUEUE(Q, 5). (c) The configuration of the queue after the call DEQUEUE(Q) returns the
key value 15 formerly at the head of the queue. The new head has key 6.
In our procedures ENQUEUE and DEQUEUE, the error checking for underflow and overflow
has been omitted. (Exercise 10.1-4 asks you to supply code that checks for these two error
conditions.)
ENQUEUE(Q, x)
1 Q[tail[Q]] ← x

