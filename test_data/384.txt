Suppose that disk hardware allows us to choose the size of a disk page arbitrarily, but that the
time it takes to read the disk page is a + bt, where a and b are specified constants and t is the
minimum degree for a B-tree using pages of the selected size. Describe how to choose t so as
to minimize (approximately) the B-tree search time. Suggest an optimal value of t for the case
in which a = 5 milliseconds and b = 10 microseconds.

18.3 Deleting a key from a B-tree
Deletion from a B-tree is analogous to insertion but a little more complicated, because a key
may be deleted from any node-not just a leaf-and deletion from an internal node requires that
the node's children be rearranged. As in insertion, we must guard against deletion producing a
tree whose structure violates the B-tree properties. Just as we had to ensure that a node didn't
get too big due to insertion, we must ensure that a node doesn't get too small during deletion
(except that the root is allowed to have fewer than the minimum number t - 1 of keys, though
it is not allowed to have more than the maximum number 2t - 1 of keys). Just as a simple
insertion algorithm might have to back up if a node on the path to where the key was to be
inserted was full, a simple approach to deletion might have to back up if a node (other than
the root) along the path to where the key is to be deleted has the minimum number of keys.
Assume that procedure B-TREE-DELETE is asked to delete the key k from the subtree rooted
at x. This procedure is structured to guarantee that whenever B-TREE-DELETE is called
recursively on a node x, the number of keys in x is at least the minimum degree t. Note that
this condition requires one more key than the minimum required by the usual B-tree
conditions, so that sometimes a key may have to be moved into a child node before recursion
descends to that child. This strengthened condition allows us to delete a key from the tree in
one downward pass without having to "back up" (with one exception, which we'll explain).
The following specification for deletion from a B-tree should be interpreted with the
understanding that if it ever happens that the root node x becomes an internal node having no
keys (this situation can occur in cases 2c and 3b, below), then x is deleted and x's only child
c1[x] becomes the new root of the tree, decreasing the height of the tree by one and preserving
the property that the root of the tree contains at least one key (unless the tree is empty).
We sketch how deletion works instead of presenting the pseudocode. Figure 18.8 illustrates
the various cases of deleting keys from a B-tree.

