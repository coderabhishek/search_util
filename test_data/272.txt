The only new operation we need is INTERVAL-SEARCH(T, i), which finds a node in tree T
whose interval overlaps interval i. If there is no interval that overlaps i in the tree, a pointer to
the sentinel nil[T] is returned.
INTERVAL-SEARCH(T, i)
1 x ← root[T]
2 while x ≠ nil[T] and i does not overlap int[x]
3
do if left[x] ≠ nil[T] and max[left[x]] ≥ low[i]
4
then x ← left[x]
5
else x ← right[x]
6 return x

The search for an interval that overlaps i starts with x at the root of the tree and proceeds
downward. It terminates when either an overlapping interval is found or x points to the
sentinel nil[T]. Since each iteration of the basic loop takes O(1) time, and since the height of
an n-node red-black tree is O(lg n), the INTERVAL-SEARCH procedure takes O(lg n) time.
Before we see why INTERVAL-SEARCH is correct, let's examine how it works on the
interval tree in Figure 14.4. Suppose we wish to find an interval that overlaps the interval i =
[22, 25]. We begin with x as the root, which contains [16, 21] and does not overlap i. Since
max[left[x]] = 23 is greater than low[i] = 22, the loop continues with x as the left child of the
root—the node containing [8, 9], which also does not overlap i. This time, max[left[x]] = 10 is
less than low[i] = 22, so the loop continues with the right child of x as the new x. The interval
[15, 23] stored in this node overlaps i, so the procedure returns this node.
As an example of an unsuccessful search, suppose we wish to find an interval that overlaps i =
[11, 14] in the interval tree of Figure 14.4. We once again begin with x as the root. Since the
root's interval [16, 21] does not overlap i, and since max[left[x]] = 23 is greater than low[i] =
11, we go left to the node containing [8, 9]. (Note that no interval in the right subtree overlaps
i—we shall see why later.) Interval [8, 9] does not overlap i, and max[left[x]] = 10 is less than
low[i] = 11, so we go right. (Note that no interval in the left subtree overlaps i.) Interval [15,
23] does not overlap i, and its left child is nil[T], so we go right, the loop terminates, and the
sentinel nil[T] is returned.
To see why INTERVAL-SEARCH is correct, we must understand why it suffices to examine
a single path from the root. The basic idea is that at any node x, if int[x] does not overlap i, the
search always proceeds in a safe direction: an overlapping interval will definitely be found if
there is one in the tree. The following theorem states this property more precisely.
Theorem 14.2
Any execution of INTERVAL-SEARCH(T, i) either returns a node whose interval overlaps i,
or it returns nil[T] and the tree T contains no node whose interval overlaps i.
Proof The while loop of lines 2–5 terminates either when x = nil[T] or i overlaps int[x]. In the
latter case, it is certainly correct to return x. Therefore, we focus on the former case, in which
the while loop terminates because x = nil[T].
We use the following invariant for the while loop of lines 2–5:

