fj or sj ≥ fi). The activity-selection problem is to select a maximum-size subset of mutually
compatible activities. For example, consider the following set S of activities, which we have
sorted in monotonically increasing order of finish time:
i 1 2 3 4 5 6 7 8 9 10 11
si 1 3 0 5 3 5 6 8 8 2 12
fi 4 5 6 7 8 9 10 11 12 13 14
(We shall see shortly why it is advantageous to consider activities in sorted order.) For this
example, the subset {a3, a9, a11} consists of mutually compatible activities. It is not a maximal
subset, however, since the subset {a1, a4, a8, a11} is larger. In fact, {a1, a4, a8, a11} is a largest
subset of mutually compatible activities; another largest subset is {a2, a4, a9, a11}.
We shall solve this problem in several steps. We start by formulating a dynamic-programming
solution to this problem in which we combine optimal solutions to two subproblems to form
an optimal solution to the original problem. We consider several choices when determining
which subproblems to use in an optimal solution. We shall then observe that we need only
consider one choice—the greedy choice—and that when we make the greedy choice, one of
the subproblems is guaranteed to be empty, so that only one nonempty subproblem remains.
Based on these observations, we shall develop a recursive greedy algorithm to solve the
activity-scheduling problem. We shall complete the process of developing a greedy solution
by converting the recursive algorithm to an iterative one. Although the steps we shall go
through in this section are more involved than is typical for the development of a greedy
algorithm, they illustrate the relationship of greedy algorithms and dynamic programming.
The optimal substructure of the activity-selection problem
As mentioned above, we start by developing a dynamic-programming solution to the activityselection problem. As in Chapter 15, our first step is to find the optimal substructure and then
use it to construct an optimal solution to the problem from optimal solutions to subproblems.
We saw in Chapter 15 that we need to define an appropriate space of subproblems. Let us
start by defining sets
Sij = {ak

S : f i ≤ s k < f k ≤ s j} ,

so that Sij is the subset of activities in S that can start after activity ai finishes and finish before
activity aj starts. In fact, Sij consists of all activities that are compatible with ai and aj and are
also compatible with all activities that finish no later than ai finishes and all activities that start
no earlier than aj starts. In order to represent to entire problem, we add fictitious activities a0
and an+1 and adopt the conventions that f0 = 0 and sn+1 = ∞. Then S = S0.n+1, and the ranges for
i and j are given by 0 ≤ i, j ≤ n + 1.
We can further restrict the ranges of i and j as follows. Let us assume that the activities are
sorted in monotonically increasing order of finish time:
(16.1)

