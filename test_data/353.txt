empty stack. Recall the analogy of Section 10.1 between the stack data structure and a stack
of plates in a cafeteria. When we push a plate on the stack, we use 1 dollar to pay the actual
cost of the push and are left with a credit of 1 dollar (out of the 2 dollars charged), which we
put on top of the plate. At any point in time, every plate on the stack has a dollar of credit on
it.
The dollar stored on the plate is prepayment for the cost of popping it from the stack. When
we execute a POP operation, we charge the operation nothing and pay its actual cost using the
credit stored in the stack. To pop a plate, we take the dollar of credit off the plate and use it to
pay the actual cost of the operation. Thus, by charging the PUSH operation a little bit more,
we needn't charge the POP operation anything.
Moreover, we needn't charge MULTIPOP operations anything either. To pop the first plate,
we take the dollar of credit off the plate and use it to pay the actual cost of a POP operation.
To pop a second plate, we again have a dollar of credit on the plate to pay for the POP
operation, and so on. Thus, we have always charged enough up front to pay for MULTIPOP
operations. In other words, since each plate on the stack has 1 dollar of credit on it, and the
stack always has a nonnegative number of plates, we have ensured that the amount of credit is
always nonnegative. Thus, for any sequence of n PUSH, POP, and MULTIPOP operations,
the total amortized cost is an upper bound on the total actual cost. Since the total amortized
cost is O(n), so is the total actual cost.
Incrementing a binary counter
As another illustration of the accounting method, we analyze the INCREMENT operation on
a binary counter that starts at zero. As we observed earlier, the running time of this operation
is proportional to the number of bits flipped, which we shall use as our cost for this example.
Let us once again use a dollar bill to represent each unit of cost (the flipping of a bit in this
example).
For the amortized analysis, let us charge an amortized cost of 2 dollars to set a bit to 1. When
a bit is set, we use 1 dollar (out of the 2 dollars charged) to pay for the actual setting of the bit,
and we place the other dollar on the bit as credit to be used later when we flip the bit back to
0. At any point in time, every 1 in the counter has a dollar of credit on it, and thus we needn't
charge anything to reset a bit to 0; we just pay for the reset with the dollar bill on the bit.
The amortized cost of INCREMENT can now be determined. The cost of resetting the bits
within the while loop is paid for by the dollars on the bits that are reset. At most one bit is set,
in line 6 of INCREMENT, and therefore the amortized cost of an INCREMENT operation is
at most 2 dollars. The number of 1's in the counter is never negative, and thus the amount of
credit is always nonnegative. Thus, for n INCREMENT operations, the total amortized cost is
O(n), which bounds the total actual cost.
Exercises 17.2-1
A sequence of stack operations is performed on a stack whose size never exceeds k. After
every k operations, a copy of the entire stack is made for backup purposes. Show that the cost
of n stack operations, including copying the stack, is O(n) by assigning suitable amortized
costs to the various stack operations.

