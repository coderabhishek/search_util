It is for this reason that research into the P ≠ NP question centers around the NP-complete
problems. Most theoretical computer scientists believe that P ≠ NP, which leads to the
relationships among P, NP, and NPC shown in Figure 34.6. But, for all we know, someone
may come up with a polynomial-time algorithm for an NP-complete problem, thus proving
that P = NP. Nevertheless, since no polynomial-time algorithm for any NP-complete problem
has yet been discovered, a proof that a problem is NP-complete provides excellent evidence
for its intractability.

Figure 34.6: How most theoretical computer scientists view the relationships among P, NP,
and NPC. Both P and NPC are wholly contained within NP, and P ∩ NPC = Ø.
Circuit satisfiability
We have defined the notion of an NP-complete problem, but up to this point, we have not
actually proved that any problem is NP-complete. Once we prove that at least one problem is
NP-complete, we can use polynomial-time reducibility as a tool to prove the NP-completeness
of other problems. Thus, we now focus on demonstrating the existence of an NP-complete
problem: the circuit-satisfiability problem.
Unfortunately, the formal proof that the circuit-satisfiability problem is NP-complete requires
technical detail beyond the scope of this text. Instead, we shall informally describe a proof
that relies on a basic understanding of boolean combinational circuits.
Boolean combinational circuits are built from boolean combinational elements that are
interconnected by wires. A boolean combinational element is any circuit element that has a
constant number of boolean inputs and outputs and that performs a well-defined function.
Boolean values are drawn from the set {0, 1}, where 0 represents FALSE and 1 represents
TRUE.
The boolean combinational elements that we use in the circuit-satisfiability problem compute
a simple boolean function, and they are known as logic gates. Figure 34.7 shows the three
basic logic gates that we use in the circuit-satisfiability problem: the NOT gate (or inverter),
the AND gate, and the OR gate. The NOT gate takes a single binary input x, whose value is
either 0 or 1, and produces a binary output z whose value is opposite that of the input value.
Each of the other two gates takes two binary inputs x and y and produces a single binary
output z.

