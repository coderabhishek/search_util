are in chaining. Thus, in open addressing, the hash table can "fill up" so that no further
insertions can be made; the load factor α can never exceed 1.
Of course, we could store the linked lists for chaining inside the hash table, in the otherwise
unused hash-table slots (see Exercise 11.2-4), but the advantage of open addressing is that it
avoids pointers altogether. Instead of following pointers, we compute the sequence of slots to
be examined. The extra memory freed by not storing pointers provides the hash table with a
larger number of slots for the same amount of memory, potentially yielding fewer collisions
and faster retrieval.
To perform insertion using open addressing, we successively examine, or probe, the hash
table until we find an empty slot in which to put the key. Instead of being fixed in the order 0,
1, ..., m - 1 (which requires Θ(n) search time), the sequence of positions probed depends upon
the key being inserted. To determine which slots to probe, we extend the hash function to
include the probe number (starting from 0) as a second input. Thus, the hash function
becomes
h : U × {0, 1, ..., m - 1} → {0, 1, ..., m - 1}.
With open addressing, we require that for every key k, the probe sequence
h(k,0),h(k,1), ..., h(k,m - 1)
be a permutation of 0, 1, ..., m -1 , so that every hash-table position is eventually
considered as a slot for a new key as the table fills up. In the following pseudocode, we
assume that the elements in the hash table T are keys with no satellite information; the key k is
identical to the element containing key k. Each slot contains either a key or NIL (if the slot is
empty).
HASH-INSERT(T, k)
1 i ← 0
2 repeat j ← h(k, i)
3
if T[j] = NIL
4
then T[j] ← k
5
return j
6
else i ← i + 1
7
until i = m
8 error "hash table overflow"

The algorithm for searching for key k probes the same sequence of slots that the insertion
algorithm examined when key k was inserted. Therefore, the search can terminate
(unsuccessfully) when it finds an empty slot, since k would have been inserted there and not
later in its probe sequence. (This argument assumes that keys are not deleted from the hash
table.) The procedure HASH-SEARCH takes as input a hash table T and a key k, returning j if
slot j is found to contain key k, or NIL if key k is not present in table T.
HASH-SEARCH(T, k)
1 i ← 0
2 repeat j ← h(k, i)
3
if T[j] = k
4
then return j
5
i ← i + 1
6
until T[j] = NIL or i = m

