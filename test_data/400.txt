Figure 19.7: The action of BINOMIAL-HEAP-EXTRACT-MIN. (a) A binomial heap H. (b)
The root x with minimum key is removed from the root list of H . (c) The linked list of x's
children is reversed, giving another binomial heap H′. (d) The result of uniting H and H'.
Since each of lines 1-4 takes O(lg n) time if H has n nodes, BINOMIAL-HEAP-EXTRACTMIN runs in O(lg n) time.
Decreasing a key
The following procedure decreases the key of a node x in a binomial heap H to a new value k.
It signals an error if k is greater than x's current key.
BINOMIAL-HEAP-DECREASE-KEY(H, x, k)
1 if k > key[x]
2
then error "new key is greater than current key"
3 key[x] ← k
4 y ← x
5 z ← p[y]
6 while z ≠ NIL and key[y] < key[z]
7
do exchange key[y] ↔ key[z]
8
9
10

▸ If y and z have satellite fields, exchange them, too.
y ← z
z ← p[y]

As shown in Figure 19.8, this procedure decreases a key in the same manner as in a binary
min-heap: by "bubbling up" the key in the heap. After ensuring that the new key is in fact no
greater than the current key and then assigning the new key to x, the procedure goes up the
tree, with y initially pointing to node x. In each iteration of the while loop of lines 6-10, key[y]
is checked against the key of y's parent z. If y is the root or key[y] ≥ key[z], the binomial tree is
now min-heap-ordered. Otherwise, node y violates min-heap ordering, and so its key is
exchanged with the key of its parent z, along with any other satellite information. The
procedure then sets y to z, going up one level in the tree, and continues with the next iteration.

