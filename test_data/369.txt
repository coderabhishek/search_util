and let T′ be the tree that results from applying any nonterminating case of RB-INSERTFIXUP or RB-DELETE-FIXUP to T .
f. Show that Φ(T′) ≤ Φ(T) - 1 for all nonterminating cases of RB-INSERT-FIXUP.
Argue that the amortized number of structural modifications performed by any call of
RB-INSERT-FIXUP is O(1).
g. Show that Φ(T′) ≤ Φ(T) - 1 for all nonterminating cases of RB-DELETE-FIXUP.
Argue that the amortized number of structural modifications performed by any call of
RB-DELETE-FIXUP is O(1).
h. Complete the proof that in the worst case, any sequence of m RB-INSERT and RBDELETE operations performs O(m) structural modifications.

[1]

In some situations, such as an open-address hash table, we may wish to consider a table to
be full if its load factor equals some constant strictly less than 1. (See Exercise 17.4-1.)

Chapter notes
Aggregate analysis was used by Aho, Hopcroft, and Ullman [5]. Tarjan [293] surveys the
accounting and potential methods of amortized analysis and presents several applications. He
attributes the accounting method to several authors, including M. R. Brown, R. E. Tarjan, S.
Huddleston, and K. Mehlhorn. He attributes the potential method to D. D. Sleator. The term
"amortized" is due to D. D. Sleator and R. E. Tarjan.
Potential functions are also useful for proving lower bounds for certain types of problems. For
each configuration of the problem, we define a potential function that maps the configuration
to a real number. Then we determine the potential Φinit of the initial configuration, the
potential Φfinal of the final configuration, and the maximum change in potential ∆Φmax due to
any step. The number of steps must therefore be at least |Φfinal - Φinit|/|∆Φmax|. Examples of the
use of potential functions for proving lower bounds in I/O complexity appear in works by
Cormen [71], Floyd [91], and Aggarwal and Vitter [4]. Krumme, Cybenko, and
Venkataraman [194] applied potential functions to prove lower bounds on gossiping:
communicating a unique item from each vertex in a graph to every other vertex.

Part V: Advanced Data Structures
Chapter List
Chapter 18: B-Trees
Chapter 19: Binomial Heaps
Chapter 20: Fibonacci Heaps
Chapter 21: Data Structures for Disjoint Sets

Introduction

