with A[4], which destroys the max-heap property for node 4. The recursive call MAXHEAPIFY(A, 4) now has i = 4. After swapping A[4] with A[9], as shown in (c), node 4 is
fixed up, and the recursive call MAX-HEAPIFY(A, 9) yields no further change to the data
structure.
The running time of MAX-HEAPIFY on a subtree of size n rooted at given node i is the Θ(1)
time to fix up the relationships among the elements A[i], A[LEFT(i)], and A[RIGHT(i)], plus
the time to run MAX-HEAPIFY on a subtree rooted at one of the children of node i. The
children's subtrees each have size at most 2n/3-the worst case occurs when the last row of the
tree is exactly half full-and the running time of MAX-HEAPIFY can therefore be described
by the recurrence
T (n) ≤ T(2n/3) + Θ(1).
The solution to this recurrence, by case 2 of the master theorem (Theorem 4.1), is T (n) = O(lg
n). Alternatively, we can characterize the running time of MAX-HEAPIFY on a node of
height h as O(h).
Exercises 6.2-1
Using Figure 6.2 as a model, illustrate the operation of MAX-HEAPIFY(A, 3) on the array A
= 27, 17, 3, 16, 13, 10, 1, 5, 7, 12, 4, 8, 9, 0 .

Exercises 6.2-2
Starting with the procedure MAX-HEAPIFY, write pseudocode for the procedure MINHEAPIFY(A, i), which performs the corresponding manipulation on a min-heap. How does
the running time of MIN-HEAPIFY compare to that of MAX-HEAPIFY?

Exercises 6.2-3
What is the effect of calling MAX-HEAPIFY(A, i) when the element A[i] is larger than its
children?

Exercises 6.2-4
What is the effect of calling MAX-HEAPIFY(A, i) for i > heap-size[A]/2?

