into an existing leaf node. Since we cannot insert a key into a leaf node that is full, we
introduce an operation that splits a full node y (having 2t - 1 keys) around its median key
keyt[y] into two nodes having t - 1 keys each. The median key moves up into y's parent to
identify the dividing point between the two new trees. But if y's parent is also full, it must be
split before the new key can be inserted, and thus this need to split full nodes can propagate
all the way up the tree.
As with a binary search tree, we can insert a key into a B-tree in a single pass down the tree
from the root to a leaf. To do so, we do not wait to find out whether we will actually need to
split a full node in order to do the insertion. Instead, as we travel down the tree searching for
the position where the new key belongs, we split each full node we come to along the way
(including the leaf itself). Thus whenever we want to split a full node y, we are assured that its
parent is not full.
Splitting a node in a B-tree

The procedure B-TREE-SPLIT-CHILD takes as input a nonfull internal node x (assumed to
be in main memory), an index i, and a node y (also assumed to be in main memory) such that
y = ci[x] is a full child of x. The procedure then splits this child in two and adjusts x so that it
has an additional child. (To split a full root, we will first make the root a child of a new empty
root node, so that we can use B-TREE-SPLIT-CHILD. The tree thus grows in height by one;
splitting is the only means by which the tree grows.)
Figure 18.5 illustrates this process. The full node y is split about its median key S, which is
moved up into y's parent node x. Those keys in y that are greater than the median key are
placed in a new node z, which is made a new child of x.

Figure 18.5: Splitting a node with t = 4. Node y is split into two nodes, y and z, and the
median key S of y is moved up into y's parent.
B-TREE-SPLIT-CHILD(x, i, y)
1 z ← ALLOCATE-NODE()
2 leaf[z] ← leaf[y]
3 n[z] ← t - 1
4 for j ← 1 to t - 1
5
do keyj[z] ← keyj+t[y]
6 if not leaf [y]
7
then for j ← 1 to t
8
do cj[z] ← cj+t[y]
9 n[y] ← t - 1
10 for j ← n[x] + 1 downto i + 1
11
do cj+1[x] ← cj [x]
12 ci+1[x] ← z
13 for j ← n[x] downto i
14
do keyj+1[x] ← keyj[x]
15 keyi[x] ← keyt[y]
16 n[x] ← n[x] + 1
17 DISK-WRITE(y)

