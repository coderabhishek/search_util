In practice, heuristic techniques can often be used to create a hash function that performs well.
Qualitative information about distribution of keys may be useful in this design process. For
example, consider a compiler's symbol table, in which the keys are character strings
representing identifiers in a program. Closely related symbols, such as pt and pts, often occur
in the same program. A good hash function would minimize the chance that such variants
hash to the same slot.
A good approach is to derive the hash value in a way that is expected to be independent of any
patterns that might exist in the data. For example, the "division method" (discussed in Section
11.3.1) computes the hash value as the remainder when the key is divided by a specified
prime number. This method frequently gives good results, assuming that the prime number is
chosen to be unrelated to any patterns in the distribution of keys.
Finally, we note that some applications of hash functions might require stronger properties
than are provided by simple uniform hashing. For example, we might want keys that are
"close" in some sense to yield hash values that are far apart. (This property is especially
desirable when we are using linear probing, defined in Section 11.4.) Universal hashing,
described in Section 11.3.3, often provides the desired properties.
Interpreting keys as natural numbers
Most hash functions assume that the universe of keys is the set N = {0, 1, 2, ...} of natural
numbers. Thus, if the keys are not natural numbers, a way is found to interpret them as natural
numbers. For example, a character string can be interpreted as an integer expressed in suitable
radix notation. Thus, the identifier pt might be interpreted as the pair of decimal integers (112,
116), since p = 112 and t = 116 in the ASCII character set; then, expressed as a radix-128
integer, pt becomes (112Â·128)+116 = 14452. It is usually straightforward in an application to
devise some such method for interpreting each key as a (possibly large) natural number. In
what follows, we assume that the keys are natural numbers.

11.3.1 The division method
In the division method for creating hash functions, we map a key k into one of m slots by
taking the remainder of k divided by m. That is, the hash function is
h(k) = k mod m.
For example, if the hash table has size m = 12 and the key is k = 100, then h(k) = 4. Since it
requires only a single division operation, hashing by division is quite fast.
When using the division method, we usually avoid certain values of m. For example, m should
not be a power of 2, since if m = 2p, then h(k) is just the p lowest-order bits of k. Unless it is
known that all low-order p-bit patterns are equally likely, it is better to make the hash function
depend on all the bits of the key. As Exercise 11.3-3 asks you to show, choosing m = 2p - 1
when k is a character string interpreted in radix 2p may be a poor choice, because permuting
the characters of k does not change its hash value.
A prime not too close to an exact power of 2 is often a good choice for m. For example,
suppose we wish to allocate a hash table, with collisions resolved by chaining, to hold roughly
n = 2000 character strings, where a character has 8 bits. We don't mind examining an average

