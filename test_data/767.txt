A number x is a nontrivial square root of 1, modulo n, if it satisfies the equation x2 ≡ 1 (mod
n) but x is equivalent to neither of the two "trivial" square roots: 1 or -1, modulo n. For
example, 6 is a nontrivial square root of 1, modulo 35. The following corollary to Theorem
31.34 will be used in the correctness proof for the Miller-Rabin primality-testing procedure in
Section 31.8.
Corollary 31.35
If there exists a nontrivial square root of 1, modulo n, then n is composite.
Proof By the contrapositive of Theorem 31.34, if there exists a nontrivial square root of 1,
modulo n, then n can't be an odd prime or a power of an odd prime. If x2 ≡ 1 (mod 2), then x ≡
1 (mod 2), so all square roots of 1, modulo 2, are trivial. Thus, n cannot be prime. Finally, we
must have n > 1 for a nontrivial square root of 1 to exist. Therefore, n must be composite.

Raising to powers with repeated squaring
A frequently occurring operation in number-theoretic computations is raising one number to a
power modulo another number, also known as modular exponentiation. More precisely, we
would like an efficient way to compute ab mod n, where a and b are nonnegative integers and
n is a positive integer. Modular exponentiation is an essential operation in many primalitytesting routines and in the RSA public-key cryptosystem. The method of repeated squaring
solves this problem efficiently using the binary representation of b.
Let bk, bk-1, ..., b1, b0 be the binary representation of b. (That is, the binary representation
is k + 1 bits long, bk is the most significant bit, and b0 is the least significant bit.) The
following procedure computes ac mod n as c is increased by doublings and incrementations
from 0 to b.
MODULAR-EXPONENTIATION(a, b, n)
1 c ← 0
2 d ← 1
3 let bk, bk-1, ..., b0 be the binary representation of b
4 for i ← k downto 0
5
do c ← 2c
6
d ← (d · d) mod n
7
if bi = 1
8
then c ← c + 1
9
d ← (d · a) mod n
10 return d

The essential use of squaring in line 6 of each iteration explains the name "repeated squaring."
As an example, for a = 7, b = 560, and n = 561, the algorithm computes the sequence of
values modulo 561 shown in Figure 31.4; the sequence of exponents used is shown in the row
of the table labeled by c.

i 9 8

7

6

5

4

3

2

1

0

