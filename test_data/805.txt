Construct the string-matching automaton for the pattern P = aabab and illustrate its operation
on the text string T = aaababaabaababaab.

Exercises 32.3-2
Draw a state-transition diagram for a string-matching automaton for the pattern
ababbabbababbababbabb over the alphabet Σ = {a, b}.

Exercises 32.3-3

We call a pattern P nonoverlappable if Pk ⊐ Pq implies k = 0 or k = q. Describe the statetransition diagram of the string-matching automaton for a nonoverlappable pattern.

Exercises 32.3-4:
Given two patterns P and P′, describe how to construct a finite automaton that determines all
occurrences of either pattern. Try to minimize the number of states in your automaton.

Exercises 32.3-5
Given a pattern P containing gap characters (see Exercise 32.1-4), show how to build a finite
automaton that can find an occurrence of P in a text T in O(n) matching time, where n = |T|.

32.4

The Knuth-Morris-Pratt algorithm

We now present a linear-time string-matching algorithm due to Knuth, Morris, and Pratt.
Their algorithm avoids the computation of the transition function δ altogether, and its
matching time is Θ(n) using just an auxiliary function π[1 m] precomputed from the pattern
in time Θ(m). The array π allows the transition function δ to be computed efficiently (in an
amortized sense) "on the fly" as needed. Roughly speaking, for any state q = 0, 1, . . . , m and
any character a Σ, the value π[q] contains the information that is independent of a and is
needed to compute δ(q, a). (This remark will be clarified shortly.) Since the array π has only
m entries, whereas δ has Θ(m |Σ|) entries, we save a factor of |Σ| in the preprocessing time by
computing π rather than δ.
The prefix function for a pattern

