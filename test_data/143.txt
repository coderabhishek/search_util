The QUICKSORT algorithm of Section 7.1 contains two recursive calls to itself. After the
call to PARTITION, the left subarray is recursively sorted and then the right subarray is
recursively sorted. The second recursive call in QUICKSORT is not really necessary; it can
be avoided by using an iterative control structure. This technique, called tail recursion, is
provided automatically by good compilers. Consider the following version of quicksort,
which simulates tail recursion.
QUICKSORT'(A, p, r)
1 while p < r
2
3
4
5

do ▸ Partition and sort left subarray.
q ← PARTITION(A, p, r)
QUICKSORT'(A, p, q - 1)
p ← q + 1

a. Argue that QUICKSORT'(A, 1, length[A]) correctly sorts the array A.
Compilers usually execute recursive procedures by using a stack that contains pertinent
information, including the parameter values, for each recursive call. The information for the
most recent call is at the top of the stack, and the information for the initial call is at the
bottom. When a procedure is invoked, its information is pushed onto the stack; when it
terminates, its information is popped. Since we assume that array parameters are represented
by pointers, the information for each procedure call on the stack requires O(1) stack space.
The stack depth is the maximum amount of stack space used at any time during a
computation.
b. Describe a scenario in which the stack depth of QUICKSORT' is Θ(n) on an n-element
input array.
c. Modify the code for QUICKSORT' so that the worst-case stack depth is Θ(lg n).
Maintain the O(n lg n) expected running time of the algorithm.

Problems 7-5: Median-of-3 partition
One way to improve the RANDOMIZED-QUICKSORT procedure is to partition around a
pivot that is chosen more carefully than by picking a random element from the subarray. One
common approach is the median-of-3 method: choose the pivot as the median (middle
element) of a set of 3 elements randomly selected from the subarray. (See Exercise 7.4-6.) For
this problem, let us assume that the elements in the input array A[1 n] are distinct and that n
≥ 3. We denote the sorted output array by A'[1 n]. Using the median-of-3 method to choose
the pivot element x, define pi = Pr{x = A'[i]}.
a. Give an exact formula for pi as a function of n and i for i = 2, 3,..., n - 1. (Note that p1
= pn = 0.)
b. By what amount have we increased the likelihood of choosing the pivot as x = A'[⌊(n
+ 1/2⌋], the median of A[1 n], compared to the ordinary implementation? Assume
that n → ∞, and give the limiting ratio of these probabilities.

