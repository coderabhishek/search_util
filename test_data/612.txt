on finding blocking flows. All previous maximum-flow algorithms, including the ones in this
chapter, use some notion of distance (the push-relabel algorithms use the analogous notion of
height), with a length of 1 assigned implicitly to each edge. This new algorithm takes a
different approach and assigns a length of 0 to high-capacity edges and a length of 1 to lowcapacity edges. Informally, with respect to these lengths, shortest paths from the source to the
sink tend have high capacity, which means that fewer iterations need be performed.
In practice, push-relabel algorithms currently dominate augmenting-path or linearprogramming based algorithms for the maximum-flow problem. A study by Cherkassky and
Goldberg [56] underscores the importance of using two heuristics when implementing a pushrelabel algorithm. The first heuristic is to periodically perform a breadth-first search of the
residual graph in order to obtain more accurate height values. The second heuristic is the gap
heuristic, described in Exericse 26.5-5. They conclude that the best choice of push-relabel
variants is the one that chooses to discharge the overflowing vertex with the maximum height.
The best algorithm to date for maximum bipartite matching, discovered by Hopcroft and Karp
[152], runs in
time and is described in Problem 26-7. The book by Lov√°sz and
Plummer [207] is an excellent reference on matching problems.

Part VII: Selected Topics
Chapter List
Chapter 27: Sorting Networks
Chapter 28: Matrix Operations
Chapter 29: Linear Programming
Chapter 30: Polynomials and the FFT
Chapter 31: Number-Theoretic Algorithms
Chapter 32: String Matching
Chapter 33: Computational Geometry
Chapter 34: NP-Completeness
Chapter 35: Approximation Algorithms

Introduction
This part contains a selection of algorithmic topics that extend and complement earlier
material in this book. Some chapters introduce new models of computation such as
combinational circuits or parallel computers. Others cover specialized domains such as
computational geometry or number theory. The last two chapters discuss some of the known
limitations to the design of efficient algorithms and introduce techniques for coping with
those limitations.
Chapter 27 presents a parallel model of computation: comparison networks. Roughly
speaking, a comparison network is an algorithm that allows many comparisons to be made
simultaneously. This chapter shows how to build a comparison network that can sort n
numbers in O(lg2 n) time.

