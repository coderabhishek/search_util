Figure 12.4: Deleting a node z from a binary search tree. Which node is actually removed
depends on how many children z has; this node is shown lightly shaded. (a) If z has no
children, we just remove it. (b) If z has only one child, we splice out z. (c) If z has two
children, we splice out its successor y, which has at most one child, and then replace z's key
and satellite data with y's key and satellite data.
The code for TREE-DELETE organizes these three cases a little differently.
TREE-DELETE(T, z)
1 if left[z] = NIL or right[z] = NIL
2
then y ← z
3
else y ← TREE-SUCCESSOR(z)
4 if left[y] ≠ NIL
5
then x ← left[y]
6
else x ← right[y]
7 if x ≠ NIL
8
then p[x] ← p[y]
9 if p[y] = NIL
10
then root[T] ← x
11
else if y = left[p[y]]
12
then left[p[y]] ← x
13
else right[p[y]] ← x
14 if y ≠ z
15
then key[z] ← key[y]
16
copy y's satellite data into z
17 return y

In lines 1–3, the algorithm determines a node y to splice out. The node y is either the input
node z (if z has at most 1 child) or the successor of z (if z has two children). Then, in lines 4–
6, x is set to the non-NIL child of y, or to NIL if y has no children. The node y is spliced out in
lines 7–13 by modifying pointers in p[y] and x. Splicing out y is somewhat complicated by the
need for proper handling of the boundary conditions, which occur when x = NIL or when y is
the root. Finally, in lines 14–16, if the successor of z was the node spliced out, y's key and
satellite data are moved to z, overwriting the previous key and satellite data. The node y is
returned in line 17 so that the calling procedure can recycle it via the free list. The procedure
runs in O(h) time on a tree of height h.
In summary, we have proved the following theorem.

