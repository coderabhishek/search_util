We can tighten our analysis to yield a worst-case cost of O(n) for a sequence of n
INCREMENT's by observing that not all bits flip each time INCREMENT is called. As
Figure 17.2 shows, A[0] does flip each time INCREMENT is called. The next-highest-order
bit, A[1], flips only every other time: a sequence of n INCREMENT operations on an initially
zero counter causes A[1] to flip ⌈n/2⌉ times. Similarly, bit A[2] flips only every fourth time,
or ⌈n/4⌉ times in a sequence of n INCREMENT's. In general, for i = 0, 1, ..., ⌈lg n⌉, bit A[i]
flips ⌈n/2i⌉ times in a sequence of n INCREMENT operations on an initially zero counter.

For i > ⌈lg n⌉, bit A[i] never flips at all. The total number of flips in the sequence is thus

by equation (A.6). The worst-case time for a sequence of n INCREMENT operations on an
initially zero counter is therefore O(n). The average cost of each operation, and therefore the
amortized cost per operation, is O(n)/n = O(1).
Exercises 17.1-1
If the set of stack operations included a MULTIPUSH operation, which pushes k items onto
the stack, would the O(1) bound on the amortized cost of stack operations continue to hold?

Exercises 17.1-2
Show that if a DECREMENT operation were included in the k-bit counter example, n
operations could cost as much as Θ(nk) time.

Exercises 17.1-3
A sequence of n operations is performed on a data structure. The ith operation costs i if i is an
exact power of 2, and 1 otherwise. Use aggregate analysis to determine the amortized cost per
operation.

17.2 The accounting method
In the accounting method of amortized analysis, we assign differing charges to different
operations, with some operations charged more or less than they actually cost. The amount we
charge an operation is called its amortized cost. When an operation's amortized cost exceeds

