Professor Marley hypothesizes that substantial performance gains can be obtained if we
modify the chaining scheme so that each list is kept in sorted order. How does the professor's
modification affect the running time for successful searches, unsuccessful searches, insertions,
and deletions?

Exercises 11.2-4
Suggest how storage for elements can be allocated and deallocated within the hash table itself
by linking all unused slots into a free list. Assume that one slot can store a flag and either one
element plus a pointer or two pointers. All dictionary and free-list operations should run in
O(1) expected time. Does the free list need to be doubly linked, or does a singly linked free
list suffice?

Exercises 11.2-5
Show that if |U| > nm, there is a subset of U of size n consisting of keys that all hash to the
same slot, so that the worst-case searching time for hashing with chaining is Θ(n).

11.3 Hash functions
In this section, we discuss some issues regarding the design of good hash functions and then
present three schemes for their creation. Two of the schemes, hashing by division and hashing
by multiplication, are heuristic in nature, whereas the third scheme, universal hashing, uses
randomization to provide provably good performance.
What makes a good hash function?
A good hash function satisfies (approximately) the assumption of simple uniform hashing:
each key is equally likely to hash to any of the m slots, independently of where any other key
has hashed to. Unfortunately, it is typically not possible to check this condition, since one
rarely knows the probability distribution according to which the keys are drawn, and the keys
may not be drawn independently.
Occasionally we do know the distribution. For example, if the keys are known to be random
real numbers k independently and uniformly distributed in the range 0 ≤ k < 1, the hash
function
h(k) = ⌊km⌋
satisfies the condition of simple uniform hashing.

