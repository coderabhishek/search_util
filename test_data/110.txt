•

Output: A permutation (reordering)
.

of the input sequence such that

The input sequence is usually an n-element array, although it may be represented in some
other fashion, such as a linked list.

The structure of the data
In practice, the numbers to be sorted are rarely isolated values. Each is usually part of a
collection of data called a record. Each record contains a key, which is the value to be sorted,
and the remainder of the record consists of satellite data, which are usually carried around
with the key. In practice, when a sorting algorithm permutes the keys, it must permute the
satellite data as well. If each record includes a large amount of satellite data, we often permute
an array of pointers to the records rather than the records themselves in order to minimize data
movement.
In a sense, it is these implementation details that distinguish an algorithm from a full-blown
program. Whether we sort individual numbers or large records that contain numbers is
irrelevant to the method by which a sorting procedure determines the sorted order. Thus, when
focusing on the problem of sorting, we typically assume that the input consists only of
numbers. The translation of an algorithm for sorting numbers into a program for sorting
records is conceptually straightforward, although in a given engineering situation there may
be other subtleties that make the actual programming task a challenge.

Why sorting?
Many computer scientists consider sorting to be the most fundamental problem in the study of
algorithms. There are several reasons:
•
•

•

•

•

Sometimes the need to sort information is inherent in an application. For example, in
order to prepare customer statements, banks need to sort checks by check number.
Algorithms often use sorting as a key subroutine. For example, a program that renders
graphical objects that are layered on top of each other might have to sort the objects
according to an "above" relation so that it can draw these objects from bottom to top.
We shall see numerous algorithms in this text that use sorting as a subroutine.
There is a wide variety of sorting algorithms, and they use a rich set of techniques. In
fact, many important techniques used throughout algorithm design are represented in
the body of sorting algorithms that have been developed over the years. In this way,
sorting is also a problem of historical interest.
Sorting is a problem for which we can prove a nontrivial lower bound (as we shall do
in Chapter 8). Our best upper bounds match the lower bound asymptotically, and so
we know that our sorting algorithms are asymptotically optimal. Moreover, we can use
the lower bound for sorting to prove lower bounds for certain other problems.
Many engineering issues come to the fore when implementing sorting algorithms. The
fastest sorting program for a particular situation may depend on many factors, such as
prior knowledge about the keys and satellite data, the memory hierarchy (caches and
virtual memory) of the host computer, and the software environment. Many of these
issues are best dealt with at the algorithmic level, rather than by "tweaking" the code.

Sorting algorithms

