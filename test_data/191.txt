3
4
5
6
7
8
9
10
11
12

do j ← RANDOM(1, n)
if key[i] < key[j] and key[j] ≤ k
then i ← j
if key[i] = k
then return i
while i ≠ NIL and key[i] < k
do i ← next[i]
if i = NIL or key[i] > k
then return NIL
else return i

To compare the execution of the algorithms COMPACT-LIST-SEARCH(L, k) and
COMPACT-LIST-SEARC′(L, k, t), assume that the sequence of integers returned by the calls
of RANDOM(1, n) is the same for both algorithms.
a. Suppose that COMPACT-LIST-SEARCH(L, k) takes t iterations of the while loop of
lines 2–8. Argue that COMPACT-LIST-SEARC′(L, k, t) returns the same answer and
that the total number of iterations of both the for and while loops within COMPACTLIST-SEARC′ is at least t.
In the call COMPACT-LIST-SEARC′(L, k, t), let Xt be the random variable that describes the
distance in the linked list (that is, through the chain of next pointers) from position i to the
desired key k after t iterations of the for loop of lines 2–7 have occurred.
b. Argue that the expected running time of COMPACT-LIST-SEARC′(L, k, t) is O(t + E
[Xt]).
c. Show that
. (Hint: Use equation (C.24).)
d. Show that
.
e. Prove that E [Xt] ≤ n/(t + 1).
f. Show that COMPACT-LIST-SEARC′(L, k, t) runs in O(t+n/t) expected time.
g. Conclude that COMPACT-LIST-SEARCH runs in
expected time.
h. Why do we assume that all keys are distinct in COMPACT-LIST-SEARCH? Argue
that random skips do not necessarily help asymptotically when the list contains
repeated key values.
[1]

Because we have defined a mergeable heap to support MINIMUM and EXTRACT-MIN,
we can also refer to it as a mergeable min-heap. Alternatively, if it supported MAXIMUM
and EXTRACT-MAX, it would be a mergeable max-heap.

Chapter notes
Aho, Hopcroft, and Ullman [6] and Knuth [182] are excellent references for elementary data
structures. Many other texts cover both basic data structures and their implementation in a
particular programming language. Examples of these types of textbooks include Goodrich and
Tamassia [128], Main [209], Shaffer [273], and Weiss [310, 312, 313]. Gonnet [126] provides
experimental data on the performance of many data structure operations.
The origin of stacks and queues as data structures in computer science is unclear, since
corresponding notions already existed in mathematics and paper-based business practices
before the introduction of digital computers. Knuth [182] cites A. M. Turing for the
development of stacks for subroutine linkage in 1947.

