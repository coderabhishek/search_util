The class NP consists of those problems that are "verifiable" in polynomial time. What we
mean here is that if we were somehow given a "certificate" of a solution, then we could verify
that the certificate is correct in time polynomial in the size of the input to the problem. For
example, in the hamiltonian-cycle problem, given a directed graph G = (V, E), a certificate
would be a sequence v1, v2, v3, ..., v|V| of |V| vertices. It is easy to check in polynomial time
that (vi, vi+1) E for i = 1, 2, 3, ..., |V| - 1 and that (v|V|, v1) E as well. As another example,
for 3-CNF satisfiability, a certificate would be an assignment of values to variables. We can
easily check in polynomial time that this assignment satisfies the boolean formula.
Any problem in P is also in NP, since if a problem is in P then we can solve it in polynomial
time without even being given a certificate. We will formalize this notion later in this chapter,
but for now we can believe that P NP. The open question is whether or not P is a proper
subset of NP.
Informally, a problem is in the class NPC-and we refer to it as being NP-complete-if it is in
NP and is as "hard" as any problem in NP. We shall formally define what it means to be as
hard as any problem in NP later in this chapter. In the meantime, we will state without proof
that if any NP-complete problem can be solved in polynomial time, then every NP-complete
problem has a polynomial-time algorithm. Most theoretical computer scientists believe that
the NP-complete problems are intractable, since given the wide range of NP-complete
problems that have been studied to date-without anyone having discovered a polynomial-time
solution to any of them-it would be truly astounding if all of them could be solved in
polynomial time. Yet, given the effort devoted thus far to proving that NP-complete problems
are intractable-without a conclusive outcome-we cannot rule out the possibility that the NPcomplete problems are in fact solvable in polynomial time.
To become a good algorithm designer, you must understand the rudiments of the theory of
NP-completeness. If you can establish a problem as NP-complete, you provide good evidence
for its intractability. As an engineer, you would then do better spending your time developing
an approximation algorithm (see Chapter 35) or solving a tractable special case, rather than
searching for a fast algorithm that solves the problem exactly. Moreover, many natural and
interesting problems that on the surface seem no harder than sorting, graph searching, or
network flow are in fact NP-complete. Thus, it is important to become familiar with this
remarkable class of problems.
Overview of showing problems to be NP-complete
The techniques we use to show that a particular problem is NP-complete differ from the
techniques used throughout most of this book to design and analyze algorithms. There is a
fundamental reason for such a difference: in showing a problem to be NP-complete, we are
making a statement about how hard it is (or at least how hard we think it is), not about how
easy it is. We are not trying to prove the existence of an efficient algorithm, but rather that no
efficient algorithm is likely to exist. In this way, NP-completeness proofs are somewhat like
the proof in Section 8.1 of an â„¦(n lg n)-time lower bound for any comparison sort algorithm;
the specific techniques used for showing NP-completeness differ from the decision-tree
method used in Section 8.1, however.
We rely on three key concepts in showing a problem to be NP-complete:
Decision problems vs. optimization problems

