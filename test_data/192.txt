Pointer-based data structures also seem to be a folk invention. According to Knuth, pointers
were apparently used in early computers with drum memories. The A-1 language developed
by G. M. Hopper in 1951 represented algebraic formulas as binary trees. Knuth credits the
IPL-II language, developed in 1956 by A. Newell, J. C. Shaw, and H. A. Simon, for
recognizing the importance and promoting the use of pointers. Their IPL-III language,
developed in 1957, included explicit stack operations.

Chapter 11: Hash Tables
Overview
Many applications require a dynamic set that supports only the dictionary operations
INSERT, SEARCH, and DELETE. For example, a compiler for a computer language
maintains a symbol table, in which the keys of elements are arbitrary character strings that
correspond to identifiers in the language. A hash table is an effective data structure for
implementing dictionaries. Although searching for an element in a hash table can take as long
as searching for an element in a linked list—Θ(n) time in the worst case—in practice, hashing
performs extremely well. Under reasonable assumptions, the expected time to search for an
element in a hash table is O(1).
A hash table is a generalization of the simpler notion of an ordinary array. Directly addressing
into an ordinary array makes effective use of our ability to examine an arbitrary position in an
array in O(1) time. Section 11.1 discusses direct addressing in more detail. Direct addressing
is applicable when we can afford to allocate an array that has one position for every possible
key.
When the number of keys actually stored is small relative to the total number of possible keys,
hash tables become an effective alternative to directly addressing an array, since a hash table
typically uses an array of size proportional to the number of keys actually stored. Instead of
using the key as an array index directly, the array index is computed from the key. Section
11.2 presents the main ideas, focusing on "chaining" as a way to handle "collisions" in which
more than one key maps to the same array index. Section 11.3 describes how array indices
can be computed from keys using hash functions. We present and analyze several variations
on the basic theme. Section 11.4 looks at "open addressing," which is another way to deal
with collisions. The bottom line is that hashing is an extremely effective and practical
technique: the basic dictionary operations require only O(1) time on the average. Section 11.5
explains how "perfect hashing" can support searches in O(1) worst-case time, when the set of
keys being stored is static (that is, when the set of keys never changes once stored).

11.1 Direct-address tables
Direct addressing is a simple technique that works well when the universe U of keys is
reasonably small. Suppose that an application needs a dynamic set in which each element has
a key drawn from the universe U = {0, 1, ..., m - 1}, where m is not too large. We shall
assume that no two elements have the same key.
To represent the dynamic set, we use an array, or direct-address table, denoted by T[0
1], in which each position, or slot, corresponds to a key in the universe U . Figure 11.1

m-

