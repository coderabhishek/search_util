the provided cycle is hamiltonian by checking whether it is a permutation of the vertices of V
and whether each of the consecutive edges along the cycle actually exists in the graph. This
verification algorithm can certainly be implemented to run in O(n2) time, where n is the length
of the encoding of G. Thus, a proof that a hamiltonian cycle exists in a graph can be verified
in polynomial time.
We define a verification algorithm as being a two-argument algorithm A, where one
argument is an ordinary input string x and the other is a binary string y called a certificate. A
two-argument algorithm A verifies an input string x if there exists a certificate y such that A(x,
y) = 1. The language verified by a verification algorithm A is
L = {x

{0, 1}* : there exists y

{0, 1}* such that A(x, y) = 1}.

Intuitively, an algorithm A verifies a language L if for any string x

L, there is a certificate y

that A can use to prove that x L. Moreover, for any string x ∉ L, there must be no certificate
proving that x L. For example, in the hamiltonian-cycle problem, the certificate is the list of
vertices in the hamiltonian cycle. If a graph is hamiltonian, the hamiltonian cycle itself offers
enough information to verify this fact. Conversely, if a graph is not hamiltonian, there is no
list of vertices that can fool the verification algorithm into believing that the graph is
hamiltonian, since the verification algorithm carefully checks the proposed "cycle" to be sure.
The complexity class NP
The complexity class NP is the class of languages that can be verified by a polynomial-time
algorithm.[6] More precisely, a language L belongs to NP if and only if there exist a two-input
polynomial-time algorithm A and constant c such that
L = {x

{0, 1}* : there exists a certificate y with |y| = O(|x|c) such that A(x, y) = 1}.

We say that algorithm A verifies language L in polynomial time.
From our earlier discussion on the hamiltonian-cycle problem, it follows that HAM-CYCLE
NP. (It is always nice to know that an important set is nonempty.) Moreover, if L P, then
L NP, since if there is a polynomial-time algorithm to decide L, the algorithm can be easily
converted to a two-argument verification algorithm that simply ignores any certificate and
accepts exactly those input strings it determines to be in L. Thus, P NP.
It is unknown whether P = NP, but most researchers believe that P and NP are not the same
class. Intuitively, the class P consists of problems that can be solved quickly. The class NP
consists of problems for which a solution can be verified quickly. You may have learned from
experience that it is often more difficult to solve a problem from scratch than to verify a
clearly presented solution, especially when working under time constraints. Theoretical
computer scientists generally believe that this analogy extends to the classes P and NP, and
thus that NP includes languages that are not in P.
There is more compelling evidence that P ≠ NP-the existence of languages that are "NPcomplete." We shall study this class in Section 34.3.
Many other fundamental questions beyond the P ≠ NP question remain unresolved. Despite
much work by many researchers, no one even knows if the class NP is closed under

