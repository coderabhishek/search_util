Although most of this part does not rely on difficult mathematics, some sections do require
mathematical sophistication. In particular, the average-case analyses of quicksort, bucket sort,
and the order-statistic algorithm use probability, which is reviewed in Appendix C, and the
material on probabilistic analysis and randomized algorithms in Chapter 5. The analysis of the
worst-case linear-time algorithm for order statistics involves somewhat more sophisticated
mathematics than the other worst-case analyses in this part.

Chapter 6: Heapsort
Overview
In this chapter, we introduce another sorting algorithm. Like merge sort, but unlike insertion
sort, heapsort's running time is O(n lg n). Like insertion sort, but unlike merge sort, heapsort
sorts in place: only a constant number of array elements are stored outside the input array at
any time. Thus, heapsort combines the better attributes of the two sorting algorithms we have
already discussed.
Heapsort also introduces another algorithm design technique: the use of a data structure, in
this case one we call a "heap," to manage information during the execution of the algorithm.
Not only is the heap data structure useful for heapsort, but it also makes an efficient priority
queue. The heap data structure will reappear in algorithms in later chapters.
We note that the term "heap" was originally coined in the context of heapsort, but it has since
come to refer to "garbage-collected storage," such as the programming languages Lisp and
Java provide. Our heap data structure is not garbage-collected storage, and whenever we refer
to heaps in this book, we shall mean the structure defined in this chapter.

.1 Heaps
The (binary) heap data structure is an array object that can be viewed as a nearly complete
binary tree (see Section B.5.3), as shown in Figure 6.1. Each node of the tree corresponds to
an element of the array that stores the value in the node. The tree is completely filled on all
levels except possibly the lowest, which is filled from the left up to a point. An array A that
represents a heap is an object with two attributes: length[A], which is the number of elements
in the array, and heap-size[A], the number of elements in the heap stored within array A. That
is, although A[1 length[A]] may contain valid numbers, no element past A[heap-size[A]],
where heap-size[A] ≤ length[A], is an element of the heap. The root of the tree is A[1], and
given the index i of a node, the indices of its parent PARENT(i), left child LEFT(i), and right
child RIGHT(i) can be computed simply:
PARENT(i)
return ⌊i/2⌋
LEFT(i)
return 2i
RIGHT(i)
return 2i + 1

