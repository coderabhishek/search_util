We propose to improve TREE-INSERT by testing before line 5 whether or not key[z] = key[x]
and by testing before line 11 whether or not key[z] = key[y].If equality holds, we implement
one of the following strategies. For each strategy, find the asymptotic performance of
inserting n items with identical keys into an initially empty binary search tree. (The strategies
are described for line 5, in which we compare the keys of z and x. Substitute y for x to arrive
at the strategies for line 11.)
b. Keep a boolean flag b[x] at node x, and set x to either left[x] or right[x] based on the
value of b[x], which alternates between FALSE and TRUE each time x is visited
during insertion of a node with the same key as x.
c. Keep a list of nodes with equal keys at x, and insert z into the list.
d. Randomly set x to either left[x] or right[x]. (Give the worst-case performance
and informally derive the average-case performance.)

Problems 12-2: Radix trees
Given two strings a = a0a1...ap and b = b0b1...bq, where each ai and each bj is in some ordered
set of characters, we say that string a is lexicographically less than string b if either
1. there exists an integer j, where 0 ≤ j ≤ min(p, q), such that ai = bi for all i = 0, 1, ..., j 1 and aj < bj, or
2. p < q and ai = bi for all i = 0, 1, ..., p.
For example, if a and b are bit strings, then 10100 < 10110 by rule 1 (letting j = 3) and 10100
< 101000 by rule 2. This is similar to the ordering used in English-language dictionaries.
The radix tree data structure shown in Figure 12.5 stores the bit strings 1011, 10, 011, 100,
and 0. When searching for a key a = a0a1...ap, we go left at a node of depth i if ai = 0 and right
if ai = 1. Let S be a set of distinct binary strings whose lengths sum to n. Show how to use a
radix tree to sort S lexicographically in Θ(n) time. For the example in Figure 12.5, the output
of the sort should be the sequence 0, 011, 10, 100, 1011.

Figure 12.5: A radix tree storing the bit strings 1011, 10, 011, 100, and 0. Each node's key can
be determined by traversing the path from the root to that node. There is no need, therefore, to
store the keys in the nodes; the keys are shown here for illustrative purposes only. Nodes are
heavily shaded if the keys corresponding to them are not in the tree; such nodes are present
only to establish a path to other nodes.

