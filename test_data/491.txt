Tarjan [98] give an algorithm that runs in O(E lg* V) time. Gabow, Galil, Spencer, and Tarjan
[102] improved this algorithm to run in O(E lg lg* V) time. Chazelle [53] gives an algorithm
that runs in
time, where
is the functional inverse of Ackermann's function.
(See the chapter notes for Chapter 21 for a brief discussion of Ackermann's function and its
inverse.) Unlike previous minimum-spanning-tree algorithms, Chazelle's algorithm does not
follow the greedy method.
A related problem is spanning tree verification, in which we are given a graph G = (V, E) and
a tree T E, and we wish to determine whether T is a minimum spanning tree of G. King
[177] gives a linear-time algorithm for spanning tree verification, building on earlier work of
Komlós [188] and Dixon, Rauch, and Tarjan [77].
The above algorithms are all deterministic and fall into the comparison-based model
described in Chapter 8. Karger, Klein, and Tarjan [169] give a randomized minimumspanning-tree algorithm that runs in O(V + E) expected time. This algorithm uses recursion in
a manner similar to the linear-time selection algorithm in Section 9.3: a recursive call on an
auxiliary problem identifies a subset of the edges E′ that cannot be in any minimum spanning
tree. Another recursive call on E - E′ then finds the minimum spanning tree. The algorithm
also uses ideas from Boruvka's algorithm and King's algorithm for spanning tree verification.
Fredman and Willard [100] showed how to find a minimum spanning tree in O(V + E) time
using a deterministic algorithm that is not comparison based. Their algorithm assumes that the
data are b-bit integers and that the computer memory consists of addressable b-bit words.

Chapter 24: Single-Source Shortest Paths
Overview
A motorist wishes to find the shortest possible route from Chicago to Boston. Given a road
map of the United States on which the distance between each pair of adjacent intersections is
marked, how can we determine this shortest route?
One possible way is to enumerate all the routes from Chicago to Boston, add up the distances
on each route, and select the shortest. It is easy to see, however, that even if we disallow
routes that contain cycles, there are millions of possibilities, most of which are simply not
worth considering. For example, a route from Chicago to Houston to Boston is obviously a
poor choice, because Houston is about a thousand miles out of the way.
In this chapter and in Chapter 25, we show how to solve such problems efficiently. In a
shortest-paths problem, we are given a weighted, directed graph G = (V, E), with weight
function w : E → R mapping edges to real-valued-weights. The weight of path p = v0, v1, ...,
vk is the sum of the weights of its constituent edges:

We define the shortest-path weight from u to v by

