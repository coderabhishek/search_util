Exercises 21.2-4
Give a tight asymptotic bound on the running time of the sequence of operations in Figure
21.3 assuming the linked-list representation and the weighted-union heuristic.

Exercises 21.2-5
Suggest a simple change to the UNION procedure for the linked-list representation that
removes the need to keep the tail pointer to the last object in each list. Whether or not the
weighted-union heuristic is used, your change should not change the asymptotic running time
of the UNION procedure. (Hint: Rather than appending one list to another, splice them
together.)

21.3 Disjoint-set forests
In a faster implementation of disjoint sets, we represent sets by rooted trees, with each node
containing one member and each tree representing one set. In a disjoint-set forest, illustrated
in Figure 21.4(a), each member points only to its parent. The root of each tree contains the
representative and is its own parent. As we shall see, although the straightforward algorithms
that use this representation are no faster than ones that use the linked-list representation, by
introducing two heuristics-"union by rank" and "path compression"-we can achieve the
asymptotically fastest disjoint-set data structure known.

Figure 21.4: A disjoint-set forest. (a) Two trees representing the two sets of Figure 21.2. The
tree on the left represents the set {b, c, e, h}, with c as the representative, and the tree on the
right represents the set {d, f, g}, with f as the representative. (b) The result of UNION(e, g).
We perform the three disjoint-set operations as follows. A MAKE-SET operation simply
creates a tree with just one node. We perform a FIND-SET operation by following parent
pointers until we find the root of the tree. The nodes visited on this path toward the root
constitute the find path. A UNION operation, shown in Figure 21.4(b), causes the root of one
tree to point to the root of the other.
Heuristics to improve the running time
So far, we have not improved on the linked-list implementation. A sequence of n - 1 UNION
operations may create a tree that is just a linear chain of n nodes. By using two heuristics,

