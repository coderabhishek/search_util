(29.52)
(29.53)
(29.54)
(29.55)
Multicommodity flow
As a final example, we consider another flow problem. Suppose that the Lucky Puck
company from Section 26.1 decides to diversify its product line and ship not only hockey
pucks, but also hockey sticks and hockey helmets. Each piece of equipment is manufactured
in its own factory, has its own warehouse, and must be shipped, each day, from factory to
warehouse. The sticks are manufactured in Vancouver and must be shipped to Saskatoon, and
the helmets are manufactured in Edmonton and must be shipped to Regina. The capacity of
the shipping network does not change, however, and the different items, or commodities, must
share the same network.
This example is an instance of a multicommodity-flow problem. In this problem, we are again
given a directed graph G = (V, E) in which each edge (u, v) E has a nonnegative capacity
c(u, v) ≥ 0. As in the maximum-flow problem, we implicitly assume that c(u, v) = 0 for (u, v)
∉ E. In addition, we are given k different commodities, K1, K2, ..., Kk, where commodity i is
specified by the triple Ki = (si, ti, di). Here, si is the source of commodity i, ti is the sink of
commodity i, and di is the demand, which is the desired flow value for commodity i from si to
ti. We define a flow for commodity i, denoted by fi, (so that fi(u, v) is the flow of commodity i
from vertex u to vertex v) to be a real-valued function that satisfies the flow-conservation,
skew-symmetry, and capacity constraints. We now define f (u, v), the aggregate flow, to be
sum of the various commodity flows, so that
. The aggregate flow on
edge (u, v) must be no more than the capacity of edge (u, v). This constraint subsumes the
capacity constraints for the individual commodities. The way this problem is described, there
is nothing to minimize; we need only determine whether it is possible to find such a flow.
Thus, we write a linear program with a "null" objective function:

The only known polynomial-time algorithm for this problem is to express it as a linear
program and then solve with a polynomial-time linear-programming algorithm.
Exercises 29.2-1

