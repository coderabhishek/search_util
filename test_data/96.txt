PERMUTE-WITH-ALL(A)
1 n ← length[A]
2 for i ← 1 to n
3
do swap A[i] ↔ A[RANDOM(1, n)]

Does this code produce a uniform random permutation? Why or why not?

Exercises 5.3-4
Professor Armstrong suggests the following procedure for generating a uniform random
permutation:
PERMUTE-BY-CYCLIC(A)
1 n ← length[A]
2 offset ← RANDOM(1, n)
3 for i ← 1 to n
4
do dest ← i + offset
5
if dest > n
6
then dest ← dest -n
7
B[dest] ← A[i]
8 return B

Show that each element A[i] has a 1/n probability of winding up in any particular position in
B. Then show that Professor Armstrong is mistaken by showing that the resulting permutation
is not uniformly random.

Exercises 5.3-5:
Prove that in the array P in procedure PERMUTE-BY-SORTING, the probability that all
elements are unique is at least 1 - 1/n.

Exercises 5.3-6
Explain how to implement the algorithm PERMUTE-BY-SORTING to handle the case in
which two or more priorities are identical. That is, your algorithm should produce a uniform
random permutation, even if two or more priorities are identical.

5.4 Probabilistic analysis and further uses of indicator
random variables
This advanced section further illustrates probabilistic analysis by way of four examples. The
first determines the probability that in a room of k people, some pair shares the same birthday.

