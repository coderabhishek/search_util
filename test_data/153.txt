In the first card-sorting algorithm in this section, exactly how many sorting passes are needed
to sort d-digit decimal numbers in the worst case? How many piles of cards would an operator
need to keep track of in the worst case?

8.4 Bucket sort
Bucket sort runs in linear time when the input is drawn from a uniform distribution. Like
counting sort, bucket sort is fast because it assumes something about the input. Whereas
counting sort assumes that the input consists of integers in a small range, bucket sort assumes
that the input is generated by a random process that distributes elements uniformly over the
interval [0, 1). (See Section C.2 for a definition of uniform distribution.)
The idea of bucket sort is to divide the interval [0, 1) into n equal-sized subintervals, or
buckets, and then distribute the n input numbers into the buckets. Since the inputs are
uniformly distributed over [0, 1), we don't expect many numbers to fall into each bucket. To
produce the output, we simply sort the numbers in each bucket and then go through the
buckets in order, listing the elements in each.
Our code for bucket sort assumes that the input is an n-element array A and that each element
A[i] in the array satisfies 0 ≤ A[i] < 1. The code requires an auxiliary array B[0 n - 1] of
linked lists (buckets) and assumes that there is a mechanism for maintaining such lists.
(Section 10.2 describes how to implement basic operations on linked lists.)
BUCKET-SORT(A)
1 n ← length[A]
2 for i ← 1 to n
3
4
5
6

do insert A[i] into list B[⌊n A[i]⌋]
for i ← 0 to n - 1
do sort list B[i] with insertion sort
concatenate the lists B[0], B[1], . . ., B[n - 1] together in order

Figure 8.4 shows the operation of bucket sort on an input array of 10 numbers.

Figure 8.4: The operation of BUCKET-SORT. (a) The input array A[1 10]. (b) The array
B[0 9] of sorted lists (buckets) after line 5 of the algorithm. Bucket i holds values in the

