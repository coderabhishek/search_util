a. Show that the n/k sublists, each of length k, can be sorted by insertion sort in Θ(nk)
worst-case time.
b. Show that the sublists can be merged in Θ(n lg (n/k) worst-case time.
c. Given that the modified algorithm runs in Θ(nk + n lg (n/k)) worst-case time, what is
the largest asymptotic (Θnotation) value of k as a function of n for which the modified
algorithm has the same asymptotic running time as standard merge sort?
d. How should k be chosen in practice?

Problems 2-2: Correctness of bubblesort
Bubblesort is a popular sorting algorithm. It works by repeatedly swapping adjacent elements
that are out of order.
BUBBLESORT(A)
1 for i ← 1 to length[A]
2
do for j ← length[A] downto i + 1
3
do if A[j] < A[j - 1]
4
then exchange A[j] ↔ A[j - 1]

a. Let A′ denote the output of BUBBLESORT(A). To prove that BUBBLESORT is
correct, we need to prove that it terminates and that
(2.3)
b. where n = length[A]. What else must be proved to show that BUBBLESORT actually
sorts?
The next two parts will prove inequality (2.3).
b. State precisely a loop invariant for the for loop in lines 2-4, and prove that this loop
invariant holds. Your proof should use the structure of the loop invariant proof
presented in this chapter.
c. Using the termination condition of the loop invariant proved in part (b), state a loop
invariant for the for loop in lines 1-4 that will allow you to prove inequality (2.3).
Your proof should use the structure of the loop invariant proof presented in this
chapter.
d. What is the worst-case running time of bubblesort? How does it compare to the
running time of insertion sort?

Problems 2-3: Correctness of Horner's rule
The following code fragment implements Horner's rule for evaluating a polynomial

