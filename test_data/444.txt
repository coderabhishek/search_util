in Section 21.4 is similar to Ackermann's function, and the function α(n) is similar to the
inverse. Both α(n) and
are at most 4 for all conceivable values of m and n.) An O(m lg*
n) upper bound was proven earlier by Hopcroft and Ullman [5, 155]. The treatment in Section
21.4 is adapted from a later analysis by Tarjan [294], which is in turn based on an analysis by
Kozen [193]. Harfst and Reingold [139] give a potential-based version of Tarjan's earlier
bound.
Tarjan and van Leeuwen [295] discuss variants on the path-compression heuristic, including
"one-pass methods," which sometimes offer better constant factors in their performance than
do two-pass methods. As with Tarjan's earlier analyses of the basic path-compression
heuristic, the analyses by Tarjan and van Leeuwen are aggregate. Harfst and Reingold [139]
later showed how to make a small change to the potential function to adapt their pathcompression analysis to these one-pass variants. Gabow and Tarjan [103] show that in certain
applications, the disjoint-set operations can be made to run in O(m) time.
time is required for operations on any
Tarjan [291] showed that a lower bound of
disjoint-set data structure satisfying certain technical conditions. This lower bound was later
generalized by Fredman and Saks [97], who showed that in the worst case,
(lg n)-bit
words of memory must be accessed.

Part VI: Graph Algorithms
Chapter List
Chapter 22: Elementary Graph Algorithms
Chapter 23: Minimum Spanning Trees
Chapter 24: Single-Source Shortest Paths
Chapter 25: All-Pairs Shortest Paths
Chapter 26: Maximum Flow

Introduction
Graphs are a pervasive data structure in computer science, and algorithms for working with
them are fundamental to the field. There are hundreds of interesting computational problems
defined in terms of graphs. In this part, we touch on a few of the more significant ones.
Chapter 22 shows how we can represent a graph on a computer and then discusses algorithms
based on searching a graph using either breadth-first search or depth-first search. Two
applications of depth-first search are given: topologically sorting a directed acyclic graph and
decomposing a directed graph into its strongly connected components.
Chapter 23 describes how to compute a minimum-weight spanning tree of a graph. Such a
tree is defined as the least-weight way of connecting all of the vertices together when each
edge has an associated weight. The algorithms for computing minimum spanning trees are
good examples of greedy algorithms (see Chapter 16).
Chapters 24 and 25 consider the problem of computing shortest paths between vertices when
each edge has an associated length or "weight." Chapter 24 considers the computation of

