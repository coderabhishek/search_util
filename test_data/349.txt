3

k → k - 1

Figure 17.1 shows an example of MULTIPOP.

Figure 17.1: The action of MULTIPOP on a stack S, shown initially in (a). The top 4 objects
are popped by MULTIPOP(S, 4), whose result is shown in (b). The next operation is
MULTIPOP(S, 7), which empties the stack—shown in (c)—since there were fewer than 7
objects remaining.
What is the running time of MULTIPOP(S, k) on a stack of s objects? The actual running time
is linear in the number of POP operations actually executed, and thus it suffices to analyze
MULTIPOP in terms of the abstract costs of 1 each for PUSH and POP. The number of
iterations of the while loop is the number min(s, k)of objects popped off the stack. For each
iteration of the loop, one call is made to POP in line 2. Thus, the total cost of MULTIPOP is
min(s,k), and the actual running time is a linear function of this cost.
Let us analyze a sequence of n PUSH, POP, and MULTIPOP operations on an initially empty
stack. The worst-case cost of a MULTIPOP operation in the sequence is O(n), since the stack
size is at most n. The worst-case time of any stack operation is therefore O(n), and hence a
sequence of n operations costs O(n2), since we may have O(n) MULTIPOP operations costing
O(n) each. Although this analysis is correct, the O(n2) result, obtained by considering the
worst-case cost of each operation individually, is not tight.
Using aggregate analysis, we can obtain a better upper bound that considers the entire
sequence of n operations. In fact, although a single MULTIPOP operation can be expensive,
any sequence of n PUSH, POP, and MULTIPOP operations on an initially empty stack can
cost at most O(n). Why? Each object can be popped at most once for each time it is pushed.
Therefore, the number of times that POP can be called on a nonempty stack, including calls
within MULTIPOP, is at most the number of PUSH operations, which is at most n. For any
value of n, any sequence of n PUSH, POP, and MULTIPOP operations takes a total of O(n)
time. The average cost of an operation is O(n)/n = O(1). In aggregate analysis, we assign the
amortized cost of each operation to be the average cost. In this example, therefore, all three
stack operations have an amortized cost of O(1).
We emphasize again that although we have just shown that the average cost, and hence
running time, of a stack operation is O(1), no probabilistic reasoning was involved. We
actually showed a worst-case bound of O(n) on a sequence of n operations. Dividing this total
cost by n yielded the average cost per operation, or the amortized cost.
Incrementing a binary counter
As another example of aggregate analysis, consider the problem of implementing a k-bit
binary counter that counts upward from 0. We use an array A[0 k -1] of bits, where
length[A] = k, as the counter. A binary number x that is stored in the counter has its lowest-

