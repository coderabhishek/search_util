Both of these procedures run in O(h) time on a tree of height h since, as in TREE-SEARCH,
the sequence of nodes encountered forms a path downward from the root.
Successor and predecessor
Given a node in a binary search tree, it is sometimes important to be able to find its successor
in the sorted order determined by an inorder tree walk. If all keys are distinct, the successor of
a node x is the node with the smallest key greater than key[x]. The structure of a binary search
tree allows us to determine the successor of a node without ever comparing keys. The
following procedure returns the successor of a node x in a binary search tree if it exists, and
NIL if x has the largest key in the tree.
TREE-SUCCESSOR(x)
1 if right[x] ≠ NIL
2
then return TREE-MINIMUM (right[x])
3 y ← p[x]
4 while y ≠ NIL and x = right[y]
5
do x ← y
6
y ← p[y]
7 return y

The code for TREE-SUCCESSOR is broken into two cases. If the right subtree of node x is
nonempty, then the successor of x is just the leftmost node in the right subtree, which is found
in line 2 by calling TREE-MINIMUM(right[x]). For example, the successor of the node with
key 15 in Figure 12.2 is the node with key 17.
On the other hand, as Exercise 12.2-6 asks you to show, if the right subtree of node x is empty
and x has a successor y, then y is the lowest ancestor of x whose left child is also an ancestor
of x. In Figure 12.2, the successor of the node with key 13 is the node with key 15. To find y,
we simply go up the tree from x until we encounter a node that is the left child of its parent;
this is accomplished by lines 3–7 of TREE-SUCCESSOR.
The running time of TREE-SUCCESSOR on a tree of height h is O(h), since we either follow
a path up the tree or follow a path down the tree. The procedure TREE-PREDECESSOR,
which is symmetric to TREE-SUCCESSOR, also runs in time O(h).
Even if keys are not distinct, we define the successor and predecessor of any node x as the
node returned by calls made to TREE-SUCCESSOR(x) and TREE-PREDECESSOR(x),
respectively.
In summary, we have proved the following theorem.
Theorem 12.2
The dynamic-set operations SEARCH, MINIMUM, MAXIMUM, SUCCESSOR, and
PREDECESSOR can be made to run in O(h) time on a binary search tree of height h.

Exercises 12.2-1

