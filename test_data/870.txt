For example, the boolean formula
(x1

¬x1

¬x2)

(x3

x2

x4)

(¬x1

¬x3

is in 3-CNF. The first of its three clauses is (x1
x1, ¬x1, and ¬x2.

¬x4)
¬x1

¬x2), which contains the three literals

In 3-CNF-SAT, we are asked whether a given boolean formula φ in 3-CNF is satisfiable. The
following theorem shows that a polynomial-time algorithm that can determine the
satisfiability of boolean formulas is unlikely to exist, even when they are expressed in this
simple normal form.
Theorem 34.10
Satisfiability of boolean formulas in 3-conjunctive normal form is NP-complete.
Proof The argument we used in the proof of Theorem 34.9 to show that SAT NP applies
equally well here to show that 3-CNF-SAT NP. Thus, by Lemma 34.8, we need only show
that SAT ≤P 3-CNF-SAT.
The reduction algorithm can be broken into three basic steps. Each step progressively
transforms the input formula φ closer to the desired 3-conjunctive normal form.
The first step is similar to the one used to prove CIRCUIT-SAT ≤P SAT in Theorem 34.9.
First, we construct a binary "parse" tree for the input formula φ, with literals as leaves and
connectives as internal nodes. Figure 34.11 shows such a parse tree for the formula
(34.3)

Figure 34.11: The tree corresponding to the formula φ = ((x1 → x2) ¬((¬x1 ↔ x3)

x4)) ¬x2.

Should the input formula contain a clause such as the OR of several literals, associativity can
be used to parenthesize the expression fully so that every internal node in the resulting tree
has 1 or 2 children. The binary parse tree can now be viewed as a circuit for computing the
function.
Mimicking the reduction in the proof of Theorem 34.9, we introduce a variable yi for the
output of each internal node. Then, we rewrite the original formula φ as the AND of the root

