said to have accepted the string read so far. An input that is not accepted is said to be rejected.
Figure 32.6 illustrates these definitions with a simple two-state automaton.

Figure 32.6: A simple two-state finite automaton with state set Q = {0, 1}, start state q0 = 0,
and input alphabet Σ = {a, b}. (a) A tabular representation of the transition function δ. (b) An
equivalent state-transition diagram. State 1 is the only accepting state (shown blackened).
Directed edges represent transitions. For example, the edge from state 1 to state 0 labeled b
indicates δ(1, b) = 0. This automaton accepts those strings that end in an odd number of a's.
More precisely, a string x is accepted if and only if x = yz, where y = ε or y ends with a b, and
z = ak, where k is odd. For example, the sequence of states this automaton enters for input
abaaa (including the start state) is 0, 1, 0, 1, 0, 1 , and so it accepts this input. For input
abbaa, the sequence of states is 0, 1, 0, 0, 1, 0 , and so it rejects this input.
A finite automaton M induces a function φ, called the final-state function, from Σ* to Q such
that φ(w) is the state M ends up in after scanning the string w. Thus, M accepts a string w if
and only if φ(w) A. The function φ is defined by the recursive relation
φ(ε) = q0,
φ(wa) = δ(φ(w), a) for w

Σ*, a

Σ.

String-matching automata
There is a string-matching automaton for every pattern P; this automaton must be constructed
from the pattern in a preprocessing step before it can be used to search the text string. Figure
32.7 illustrates this construction for the pattern P = ababaca. From now on, we shall assume
that P is a given fixed patternstring; for brevity, we shall not indicate the dependence upon P
in our notation.

