Whenever a satisfiable circuit C is input to algorithm A, there is a certificate whose length is
polynomial in the size of C and that causes A to output a 1. When-ever an unsatisfiable circuit
is input, no certificate can fool A into believing that the circuit is satisfiable. Algorithm A runs
in polynomial time: with a good implementation, linear time suffices. Thus, CIRCUIT-SAT
can be verified in polynomial time, and CIRCUIT-SAT NP.

The second part of proving that CIRCUIT-SAT is NP-complete is to show that the language is
NP-hard. That is, we must show that every language in NP is polynomial-time reducible to
CIRCUIT-SAT. The actual proof of this fact is full of technical intricacies, and so we shall
settle for a sketch of the proof based on some understanding of the workings of computer
hardware.
A computer program is stored in the computer memory as a sequence of instructions. A
typical instruction encodes an operation to be performed, addresses of operands in memory,
and an address where the result is to be stored. A special memory location, called the
program counter, keeps track of which instruction is to be executed next. The program
counter is automatically incremented whenever an instruction is fetched, thereby causing the
computer to execute instructions sequentially. The execution of an instruction can cause a
value to be written to the program counter, however, and then the normal sequential execution
can be altered, allowing the computer to loop and perform conditional branches.
At any point during the execution of a program, the entire state of the computation is
represented in the computer's memory. (We take the memory to include the program itself, the
program counter, working storage, and any of the various bits of state that a computer
maintains for bookkeeping.) We call any particular state of computer memory a
configuration. The execution of an instruction can be viewed as mapping one configuration
to another. Importantly, the computer hardware that accomplishes this mapping can be
implemented as a boolean combinational circuit, which we denote by M in the proof of the
following lemma.
Lemma 34.6
The circuit-satisfiability problem is NP-hard.
Proof Let L be any language in NP. We shall describe a polynomial-time algorithm F
computing a reduction function f that maps every binary string x to a circuit C = f (x) such that
x L if and only if C CIRCUIT-SAT. Since L NP, there must exist an algorithm A that
verifies L in polynomial time. The algorithm F that we shall construct will use the two-input
algorithm A to compute the reduction function f .
Let T(n) denote the worst-case running time of algorithm A on length-n input strings, and let k
â‰¥ 1 be a constant such that T (n) = O(nk) and the length of the certificate is O(nk). (The
running time of A is actually a polynomial in the total input size, which includes both an input
string and a certificate, but since the length of the certificate is polynomial in the length n of
the input string, the running time is polynomial in n.)

