which proves the second statement. Similarly, using line 8 for each

, we have

which proves the third statement.

The formal simplex algorithm
We are now ready to formalize the simplex algorithm, which we demonstrated by example.
That example was a particularly nice one, and we could have had several other issues to
address:
•
•
•
•

How do we determine if a linear program is feasible?
What do we do if the linear program is feasible, but the initial basic solution is not
feasible?
How do we determine if a linear program is unbounded?
How do we choose the entering and leaving variables?

In Section 29.5, we shall show how to determine if a problem is feasible, and if so, how to
find a slack form in which the initial basic solution is feasible. We therefore assume that we
have a procedure INITIALIZE-SIMPLEX(A, b, c) that takes as input a linear program in
standard form, that is, an m × n matrix A = (aij), an m-dimensional vector b = (bi), and an ndimensional vector c = (cj). If the problem is infeasible, it returns a message that the program
is infeasible and then terminates. Otherwise, it returns a slack form for which the initial basic
solution is feasible.
The procedure SIMPLEX takes as input a linear program in standard form, as just described.
that is an optimal solution to the linear program described in
It returns an n-vector
(29.19)–(29.21).
SIMPLEX(A, b, c)
1 (N, B, A, b, c, v) ← INITIALIZE-SIMPLEX(A, b, c)
2 while some index j
N has cj > 0
3
do choose an index e
N for which ce > 0
4
for each index i
B
5
do if aie > 0
6
then ∆i ← bi/aie
7
else ∆i ← ∞
8
choose an index l
B that minimizes ∆i
9
if ∆l = ∞
10
then return "unbounded"
11
else (N, B, A, b, c, v) ← PIVOT(N, B, A, b, c, v, l, e)
12 for i ← 1 to n
13
do if i
B
14
then
15
else
16 return

The SIMPLEX procedure works as follows. In line 1, it calls the procedure INITIALIZESIMPLEX(A, b, c), described above, which either determines that the linear program is

