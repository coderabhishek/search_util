is perhaps surprising that it is much easier to tell whether or not a given number is prime than
it is to determine the prime factorization of the number if it is not prime.
Pseudoprimality testing
We now consider a method for primality testing that "almost works" and in fact is good
enough for many practical applications. A refinement of this method that removes the small
defect will be presented later. Let denote the nonzero elements of Zn:

If n is prime, then

.

We say that n is a base-a pseudoprime if n is composite and
(31.38)
Fermat's theorem (Theorem 31.31) implies that if n is prime, then n satisfies equation (31.38)
for every a in . Thus, if we can find any
such that n does not satisfy equation (31.38),
then n is certainly composite. Surprisingly, the converse almost holds, so that this criterion
forms an almost perfect test for primality. We test to see if n satisfies equation (31.38) for a =
2. If not, we declare n to be composite. Otherwise, we output a guess that n is prime (when, in
fact, all we know is that n is either prime or a base-2 pseudoprime).
The following procedure pretends in this manner to be checking the primality of n. It uses the
procedure MODULAR-EXPONENTIATION from Section 31.6. The input n is assumed to be
an odd integer greater than 2.
PSEUDOPRIME(n)
1

if MODULAR-EXPONENTIATION(2 = n - 1, n) ≢ 1 (mod n)

2

then return COMPOSITE

3

else return PRIME

▹ Definitely.

▹ We hope!

This procedure can make errors, but only of one type. That is, if it says that n is composite,
then it is always correct. If it says that n is prime, however, then it makes an error only if n is
a base-2 pseudoprime.
How often does this procedure err? Surprisingly rarely. There are only 22 values of n less than
10,000 for which it errs; the first four such values are 341, 561, 645, and 1105. It can be
shown that the probability that this program makes an error on a randomly chosen β-bit
number goes to zero as β ← ∞. Using more precise estimates due to Pomerance [244] of the
number of base-2 pseudoprimes of a given size, we may estimate that a randomly chosen 512bit number that is called prime by the above procedure has less than one chance in 1020 of
being a base-2 pseudoprime, and a randomly chosen 1024-bit number that is called prime has
less than one chance in 1041 of being a base-2 pseudoprime. So if you are merely trying to
find a large prime for some application, for all practical purposes you almost never go wrong
by choosing large numbers at random until one of them causes PSEUDOPRIME to output
PRIME. But when the numbers being tested for primality are not randomly chosen, we need a
better approach for testing primality. As we shall see, a little more cleverness, and some
randomization, will yield a primality-testing routine that works well on all inputs.

