•

At the start of each iteration of the for loop of lines 1-8, the subarray A[1
consists of the elements originally in A[1 j - 1] but in sorted order.

j - 1]

Figure 2.2: The operation of INSERTION-SORT on the array A = 5, 2, 4, 6, 1, 3 . Array
indices appear above the rectangles, and values stored in the array positions appear within the
rectangles. (a)-(e) The iterations of the for loop of lines 1-8. In each iteration, the black
rectangle holds the key taken from A[j], which is compared with the values in shaded
rectangles to its left in the test of line 5. Shaded arrows show array values moved one position
to the right in line 6, and black arrows indicate where the key is moved to in line 8. (f) The
final sorted array.
We use loop invariants to help us understand why an algorithm is correct. We must show
three things about a loop invariant:
•
•
•

Initialization: It is true prior to the first iteration of the loop.
Maintenance: If it is true before an iteration of the loop, it remains true before the
next iteration.
Termination: When the loop terminates, the invariant gives us a useful property that
helps show that the algorithm is correct.

When the first two properties hold, the loop invariant is true prior to every iteration of the
loop. Note the similarity to mathematical induction, where to prove that a property holds, you
prove a base case and an inductive step. Here, showing that the invariant holds before the first
iteration is like the base case, and showing that the invariant holds from iteration to iteration is
like the inductive step.
The third property is perhaps the most important one, since we are using the loop invariant to
show correctness. It also differs from the usual use of mathematical induction, in which the
inductive step is used infinitely; here, we stop the "induction" when the loop terminates.
Let us see how these properties hold for insertion sort.
•

•

Initialization: We start by showing that the loop invariant holds before the first loop
iteration, when j = 2.[1] The subarray A[1 j - 1], therefore, consists of just the single
element A[1], which is in fact the original element in A[1]. Moreover, this subarray is
sorted (trivially, of course), which shows that the loop invariant holds prior to the first
iteration of the loop.
Maintenance: Next, we tackle the second property: showing that each iteration
maintains the loop invariant. Informally, the body of the outer for loop works by
moving A[ j - 1], A[ j - 2], A[ j - 3], and so on by one position to the right until the
proper position for A[ j] is found (lines 4-7), at which point the value of A[j] is inserted
(line 8). A more formal treatment of the second property would require us to state and
show a loop invariant for the "inner" while loop. At this point, however, we prefer not
to get bogged down in such formalism, and so we rely on our informal analysis to
show that the second property holds for the outer loop.

