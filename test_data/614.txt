a subset that adds up to a given target value. The chapter also proves that the famous
traveling-salesman problem is NP-complete.
Chapter 35 shows how approximation algorithms can be used to find approximate solutions to
NP-complete problems efficiently. For some NP-complete problems, approximate solutions
that are near optimal are quite easy to produce, but for others even the best approximation
algorithms known work progressively more poorly as the problem size increases. Then, there
are some problems for which one can invest increasing amounts of computation time in return
for increasingly better approximate solutions. This chapter illustrates these possibilities with
the vertex-cover problem (unweighted and weighted versions), an optimization version of 3CNF satisfiability, the traveling-salesman problem, the set-covering problem, and the subsetsum problem.

Chapter 27: Sorting Networks
Overview
In Part II, we examined sorting algorithms for serial computers (random-access machines, or
RAM's) that allow only one operation to be executed at a time. In this chapter, we investigate
sorting algorithms based on a comparison-network model of computation, in which many
comparison operations can be performed simultaneously.
Comparison networks differ from RAM's in two important respects. First, they can only
perform comparisons. Thus, an algorithm such as counting sort (see Section 8.2) cannot be
implemented on a comparison network. Second, unlike the RAM model, in which operations
occur serially-that is, one after another-operations in a comparison network may occur at the
same time, or "in parallel." As we shall see, this characteristic allows the construction of
comparison networks that sort n values in sublinear time.
We begin in Section 27.1 by defining comparison networks and sorting networks. We also
give a natural definition for the "running time" of a comparison network in terms of the depth
of the network. Section 27.2 proves the "zero-one principle," which greatly eases the task of
analyzing the correctness of sorting networks.
The efficient sorting network that we shall design is essentially a parallel version of the
merge-sort algorithm from Section 2.3.1. Our construction will have three steps. Section 27.3
presents the design of a "bitonic" sorter that will be our basic building block. We modify the
bitonic sorter slightly in Section 27.4 to produce a merging network that can merge two sorted
sequences into one sorted sequence. Finally, in Section 27.5, we assemble these merging
networks into a sorting network that can sort n values in O(lg2 n) time.

27.1 Comparison networks
Sorting networks are comparison networks that always sort their inputs, so it makes sense to
begin our discussion with comparison networks and their characteristics. A comparison
network is composed solely of wires and comparators. A comparator, shown in Figure
27.1(a), is a device with two inputs, x and y, and two outputs, x' and y', that performs the
following function:

