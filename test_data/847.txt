The encoding of an abstract problem is therefore quite important to our under-standing of
polynomial time. We cannot really talk about solving an abstract problem without first
specifying an encoding. Nevertheless, in practice, if we rule out "expensive" encodings such
as unary ones, the actual encoding of a problem makes little difference to whether the
problem can be solved in polynomial time. For example, representing integers in base 3
instead of binary has no effect on whether a problem is solvable in polynomial time, since an
integer represented in base 3 can be converted to an integer represented in base 2 in
polynomial time.
We say that a function f : {0, 1}* â†’ {0,1}* is polynomial-time computable if there exists a
polynomial-time algorithm A that, given any input x {0, 1}*, produces as output f (x). For
some set I of problem instances, we say that two encodings e1 and e2 are polynomially related
if there exist two polynomial-time computable functions f12 and f21 such that for any i I , we
have f12(e1(i)) = e2(i) and f21(e2(i)) = e1(i).[5] That is, the encoding e2(i) can be computed from
the encoding e1(i) by a polynomial-time algorithm, and vice versa. If two encodings e1 and e2
of an abstract problem are polynomially related, whether the problem is polynomial-time
solvable or not is independent of which encoding we use, as the following lemma shows.
Lemma 34.1
Let Q be an abstract decision problem on an instance set I , and let e1 and e2 be polynomially
related encodings on I . Then, e1(Q) P if and only if e2(Q) P.
Proof We need only prove the forward direction, since the backward direction is symmetric.
Suppose, therefore, that e1(Q) can be solved in time O(nk) for some constant k. Further,
suppose that for any problem instance i, the encoding e1(i) can be computed from the
encoding e2(i) in time O(nc) for some constant c, where n = |e2(i)|. To solve problem e2(Q), on
input e2(i), we first compute e1(i) and then run the algorithm for e1(Q) on e1(i). How long does
this take? The conversion of encodings takes time O(nc), and therefore |e1(i)| = O(nc), since
the output of a serial computer cannot be longer than its running time. Solving the problem on
e1(i) takes time O(|e1(i)|k) = O(nck), which is polynomial since both c and k are constants.

Thus, whether an abstract problem has its instances encoded in binary or base 3 does not
affect its "complexity," that is, whether it is polynomial-time solvable or not, but if instances
are encoded in unary, its complexity may change. In order to be able to converse in an
encoding-independent fashion, we shall generally assume that problem instances are encoded
in any reasonable, concise fashion, unless we specifically say otherwise. To be precise, we
shall assume that the encoding of an integer is polynomially related to its binary
representation, and that the encoding of a finite set is polynomially related to its encoding as a
list of its elements, enclosed in braces and separated by commas. (ASCII is one such encoding
scheme.) With such a "standard" encoding in hand, we can derive reasonable encodings of
other mathematical objects, such as tuples, graphs, and formulas. To denote the standard
encoding of an object, we shall enclose the object in angle braces. Thus, G denotes the
standard encoding of a graph G.

