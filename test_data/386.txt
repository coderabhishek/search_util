b. Symmetrically, if the child z that follows k in node x has at least t keys, then
find the successor k′ of k in the subtree rooted at z. Recursively delete k′, and
replace k by k′ in x. (Finding k′ and deleting it can be performed in a single
downward pass.)
c. Otherwise, if both y and z have only t - 1 keys, merge k and all of z into y, so
that x loses both k and the pointer to z, and y now contains 2t - 1 keys. Then,
free z and recursively delete k from y.
3. If the key k is not present in internal node x, determine the root ci[x] of the appropriate
subtree that must contain k, if k is in the tree at all. If ci[x] has only t - 1 keys, execute
step 3a or 3b as necessary to guarantee that we descend to a node containing at least t
keys. Then, finish by recursing on the appropriate child of x.
a. If ci[x] has only t - 1 keys but has an immediate sibling with at least t keys,
give ci[x] an extra key by moving a key from x down into ci[x], moving a key
from ci[x]'s immediate left or right sibling up into x, and moving the
appropriate child pointer from the sibling into ci[x].
b. If ci[x] and both of ci[x]'s immediate siblings have t - 1 keys, merge ci[x] with
one sibling, which involves moving a key from x down into the new merged
node to become the median key for that node.
Since most of the keys in a B-tree are in the leaves, we may expect that in practice, deletion
operations are most often used to delete keys from leaves. The B-TREE-DELETE procedure
then acts in one downward pass through the tree, without having to back up. When deleting a
key in an internal node, however, the procedure makes a downward pass through the tree but
may have to return to the node from which the key was deleted to replace the key with its
predecessor or successor (cases 2a and 2b).
Although this procedure seems complicated, it involves only O(h) disk operations for a B-tree
of height h, since only O(1) calls to DISK-READ and DISK-WRITE are made between
recursive invocations of the procedure. The CPU time required is O(th) = O(t logt n).
Exercises 18.3-1
Show the results of deleting C, P, and V , in order, from the tree of Figure 18.8(f).

Exercises 18.3-2
Write pseudocode for B-TREE-DELETE.

Problems 18-1: Stacks on secondary storage
Consider implementing a stack in a computer that has a relatively small amount of fast
primary memory and a relatively large amount of slower disk storage. The operations PUSH

