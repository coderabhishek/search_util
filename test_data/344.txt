scheduling the tasks in order of monotonically increasing deadlines, since (2) implies that
the ith largest deadline is at most i. Finally, (3) trivially implies (1).

Using property 2 of Lemma 16.12, we can easily compute whether or not a given set of
tasks is independent (see Exercise 16.5-2).
The problem of minimizing the sum of the penalties of the late tasks is the same as the
problem of maximizing the sum of the penalties of the early tasks. The following
theorem thus ensures that we can use the greedy algorithm to find an independent set
A of tasks with the maximum total penalty.
Theorem 16.13

If S is a set of unit-time tasks with deadlines, andℓ is the set of all independent sets of

tasks, then the corresponding system (S,ℓ) is a matroid.
Proof Every subset of an independent set of tasks is certainly independent. To prove the
exchange property, suppose that B and A are independent sets of tasks and that |B| >;

|A|. Let k be the largest t such that Nt (B) ≤ Nt (A). (Such a value of t exists, since N0(A) =
N0(B) = 0.) Since Nn(B) = |B| and Nn(A) = |A|, but |B| >; |A|, we must have that k < n and

that Nj(B) >; Nj(A) for all j in the range k + 1 ≤ j ≤ n. Therefore, B contains more tasks
with deadline k + 1 than A does. Let ai be a task in B - A with deadline k + 1. Let A′ = A ∪
{ai}.
We now show that A′ must be independent by using property 2 of Lemma 16.12. For 0 ≤
t ≤ k, we have Nt (A′) = Nt (A) ≤ t, since A is independent. For k < t = n, we have Nt
(A′) ≤ Nt (B) ≤ t, since B is independent. Therefore, A′ is independent, completing our

proof that (S,ℓ) is a matroid.

By Theorem 16.11, we can use a greedy algorithm to find a maximum-weight
independent set of tasks A. We can then create an optimal schedule having the tasks in
A as its early tasks. This method is an efficient algorithm for scheduling unit-time tasks
with deadlines and penalties for a single processor. The running time is O(n2) using
GREEDY, since each of the O(n) independence checks made by that algorithm takes
time O(n) (see Exercise 16.5-2). A faster implementation is given in Problem 16-4.
Figure 16.7 gives an example of a problem of scheduling unit-time tasks with deadlines
and penalties for a single processor. In this example, the greedy algorithm selects tasks
a1, a2, a3, and a4, then rejects a5 and a6, and finally accepts a7. The final optimal
schedule is
a2, a4, a1, a3, a7, a5, a6 ,
which has a total penalty incurred of w5 + w6 = 50.

Task
ai

1

2

3

4

5

6

7

