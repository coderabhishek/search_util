What is it about the substructure of a longest simple path that is so different from that of a
shortest path? Although two subproblems are used in a solution to a problem for both longest
and shortest paths, the subproblems in finding the longest simple path are not independent,
whereas for shortest paths they are. What do we mean by subproblems being independent?
We mean that the solution to one subproblem does not affect the solution to another
subproblem of the same problem. For the example of Figure 15.4, we have the problem of
finding a longest simple path from q to t with two subproblems: finding longest simple paths
from q to r and from r to t. For the first of these subproblems, we choose the path q → s → t
→ r, and so we have also used the vertices s and t. We can no longer use these vertices in the
second subproblem, since the combination of the two solutions to subproblems would yield a
path that is not simple. If we cannot use vertex t in the second problem, then we cannot solve
it all, since t is required to be on the path that we find, and it is not the vertex at which we are
"splicing" together the subproblem solutions (that vertex being r). Our use of vertices s and t
in one subproblem solution prevents them from being used in the other subproblem solution.
We must use at least one of them to solve the other subproblem, however, and we must use
both of them to solve it optimally. Thus we say that these subproblems are not independent.
Looked at another way, our use of resources in solving one subproblem (those resources being
vertices) has rendered them unavailable for the other subproblem.
Why, then, are the subproblems independent for finding a shortest path? The answer is that by
nature, the subproblems do not share resources. We claim that if a vertex w is on a shortest
path p from u to v, then we can splice together any shortest path
and any shortest path
to produce a shortest path from u to v. We are assured that, other than w, no vertex can
appear in both paths p1 and p2. Why? Suppose that some vertex x ≠ w appears in both p1 and
p2, so that we can decompose p1 as
and p2 as
. By the optimal substructure
of this problem, path p has as many edges as p1 and p2 together; let's say that p has e edges.
Now let us construct a path
from u to v. This path has at most e - 2 edges, which
contradicts the assumption that p is a shortest path. Thus, we are assured that the subproblems
for the shortest-path problem are independent.
Both problems examined in Sections 15.1 and 15.2 have independent subproblems. In matrixchain multiplication, the subproblems are multiplying subchains AiAi+1 Ak and Ak+1Ak+2 Aj.
These subchains are disjoint, so that no matrix could possibly be included in both of them. In
assembly-line scheduling, to determine the fastest way through station Si,j, we look at the
fastest ways through stations S1,j-1 and S2,j-1. Because our solution to the fastest way through
station Si, j will include just one of these subproblem solutions, that subproblem is
automatically independent of all others used in the solution.
Overlapping subproblems
The second ingredient that an optimization problem must have for dynamic programming to
be applicable is that the space of subproblems must be "small" in the sense that a recursive
algorithm for the problem solves the same subproblems over and over, rather than always
generating new subproblems. Typically, the total number of distinct subproblems is a
polynomial in the input size. When a recursive algorithm revisits the same problem over and
over again, we say that the optimization problem has overlapping subproblems.[3] In contrast,
a problem for which a divide-and-conquer approach is suitable usually generates brand-new
problems at each step of the recursion. Dynamic-programming algorithms typically take
advantage of overlapping subproblems by solving each subproblem once and then storing the
solution in a table where it can be looked up when needed, using constant time per lookup.

