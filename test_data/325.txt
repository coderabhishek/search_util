[1]

We will sometimes speak of the sets Sij as subproblems rather than just sets of activities. It
will always be clear from the context whether we are referring to Sij as a set of activities or the
subproblem whose input is that set.

16.2 Elements of the greedy strategy
A greedy algorithm obtains an optimal solution to a problem by making a sequence of
choices. For each decision point in the algorithm, the choice that seems best at the moment is
chosen. This heuristic strategy does not always produce an optimal solution, but as we saw in
the activity-selection problem, sometimes it does. This section discusses some of the general
properties of greedy methods.
The process that we followed in Section 16.1 to develop a greedy algorithm was a bit more
involved than is typical. We went through the following steps:
1. Determine the optimal substructure of the problem.
2. Develop a recursive solution.
3. Prove that at any stage of the recursion, one of the optimal choices is the greedy
choice. Thus, it is always safe to make the greedy choice.
4. Show that all but one of the subproblems induced by having made the greedy choice
are empty.
5. Develop a recursive algorithm that implements the greedy strategy.
6. Convert the recursive algorithm to an iterative algorithm.
In going through these steps, we saw in great detail the dynamic-programming underpinnings
of a greedy algorithm. In practice, however, we usually streamline the above steps when
designing a greedy algorithm. We develop our substructure with an eye toward making a
greedy choice that leaves just one subproblem to solve optimally. For example, in the activityselection problem, we first defined the subproblems Sij, where both i and j varied. We then
found that if we always made the greedy choice, we could restrict the subproblems to be of
the form Si.n+1.
Alternatively, we could have fashioned our optimal substructure with a greedy choice in
mind. That is, we could have dropped the second subscript and defined subproblems of the
form Si = {ak S : fi â‰¤ sk}. Then, we could have proven that a greedy choice (the first activity
am to finish in Si), combined with an optimal solution to the remaining set Sm of compatible
activities, yields an optimal solution to Si. More generally, we design greedy algorithms
according to the following sequence of steps:
1. Cast the optimization problem as one in which we make a choice and are left with one
subproblem to solve.
2. Prove that there is always an optimal solution to the original problem that makes the
greedy choice, so that the greedy choice is always safe.
3. Demonstrate that, having made the greedy choice, what remains is a subproblem with
the property that if we combine an optimal solution to the subproblem with the greedy
choice we have made, we arrive at an optimal solution to the original problem.
We shall use this more direct process in later sections of this chapter. Nevertheless, beneath
every greedy algorithm, there is almost always a more cumbersome dynamic-programming
solution.

