Carter and Wegman introduced the notion of universal classes of hash functions in 1979 [52].
Fredman, Komlós, and Szemerédi [96] developed the perfect hashing scheme for static sets
presented in Section 11.5. An extension of their method to dynamic sets, handling insertions
and deletions in amortized expected time O(1), has been given by Dietzfelbinger et al. [73].

Chapter 12: Binary Search Trees
Overview
Search trees are data structures that support many dynamic-set operations, including
SEARCH, MINIMUM, MAXIMUM, PREDECESSOR, SUCCESSOR, INSERT, and
DELETE. Thus, a search tree can be used both as a dictionary and as a priority queue.
Basic operations on a binary search tree take time proportional to the height of the tree. For a
complete binary tree with n nodes, such operations run in Θ(lg n) worst-case time. If the tree
is a linear chain of n nodes, however, the same operations take Θ(n) worst-case time. We shall
see in Section 12.4 that the expected height of a randomly built binary search tree is O(lg n),
so that basic dynamic-set operations on such a tree take Θ(lg n) time on average.
In practice, we can't always guarantee that binary search trees are built randomly, but there
are variations of binary search trees whose worst-case performance on basic operations can be
guaranteed to be good. Chapter 13 presents one such variation, red-black trees, which have
height O(lg n). Chapter 18 introduces B-trees, which are particularly good for maintaining
databases on random-access, secondary (disk) storage.
After presenting the basic properties of binary search trees, the following sections show how
to walk a binary search tree to print its values in sorted order, how to search for a value in a
binary search tree, how to find the minimum or maximum element, how to find the
predecessor or successor of an element, and how to insert into or delete from a binary search
tree. The basic mathematical properties of trees appear in Appendix B.

12.1 What is a binary search tree?
A binary search tree is organized, as the name suggests, in a binary tree, as shown in Figure
12.1. Such a tree can be represented by a linked data structure in which each node is an object.
In addition to a key field and satellite data, each node contains fields left, right, and p that
point to the nodes corresponding to its left child, its right child, and its parent, respectively. If
a child or the parent is missing, the appropriate field contains the value NIL. The root node is
the only node in the tree whose parent field is NIL.

