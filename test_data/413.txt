set array entry A[degree[x]] to point to x. When this for loop terminates, at most one root of
each degree will remain, and the array A will point to each remaining root.
The while loop of lines 6-12 repeatedly links the root x of the tree containing node w to
another tree whose root has the same degree as x, until no other root has the same degree. This
while loop maintains the following invariant:
•

At the start of each iteration of the while loop, d = degree[x].

We use this loop invariant as follows:
•
•

•

Initialization: Line 5 ensures that the loop invariant holds the first time we enter the
loop.
Maintenance: In each iteration of the while loop, A[d] points to some root y. Because
d = degree[x] = degree[y], we want to link x and y. Whichever of x and y has the
smaller key becomes the parent of the other as a result of the link operation, and so
lines 8-9 exchange the pointers to x and y if necessary. Next, we link y to x by the call
FIB-HEAP-LINK(H, y, x) in line 10. This call increments degree[x] but leaves
degree[y] as d. Because node y is no longer a root, the pointer to it in array A is
removed in line 11. Because the call of FIB-HEAP-LINK increments the value of
degree[x], line 12 restores the invariant that d = degree[x].
Termination: We repeat the while loop until A[d] = NIL, in which case there is no
other root with the same degree as x.

After the while loop terminates, we set A[d] to x in line 13 and perform the next iteration of
the for loop.
Figures 20.3(c)-(e) show the array A and the resulting trees after the first three iterations of the
for loop of lines 3-13. In the next iteration of the for loop, three links occur; their results are
shown in Figures 20.3(f)-(h). Figures 20.3(i)-(l) show the result of the next four iterations of
the for loop.
All that remains is to clean up. Once the for loop of lines 3-13 completes, line 14 empties the
root list, and lines 15-19 reconstruct it from the array A. The resulting Fibonacci heap is
shown in Figure 20.3(m). After consolidating the root list, FIB-HEAP-EXTRACT-MIN
finishes up by decrementing n[H] in line 11 and returning a pointer to the deleted node z in
line 12.
Observe that if all trees in the Fibonacci heap are unordered binomial trees before FIB-HEAPEXTRACT-MIN is executed, then they are all unordered binomial trees afterward. There are
two ways in which trees are changed. First, in lines 3-5 of FIB-HEAP-EXTRACT-MIN, each
child x of root z becomes a root. By Exercise 20.2-2, each new tree is itself an unordered
binomial tree. Second, trees are linked by FIB-HEAP-LINK only if they have the same
degree. Since all trees are unordered binomial trees before the link occurs, two trees whose
roots each have k children must have the structure of Uk. The resulting tree therefore has the
structure of Uk+1.
We are now ready to show that the amortized cost of extracting the minimum node of an nnode Fibonacci heap is O(D(n)). Let H denote the Fibonacci heap just prior to the FIB-HEAPEXTRACT-MIN operation.

