Exercises 6.2-5
The code for MAX-HEAPIFY is quite efficient in terms of constant factors, except possibly
for the recursive call in line 10, which might cause some compilers to produce inefficient
code. Write an efficient MAX-HEAPIFY that uses an iterative control construct (a loop)
instead of recursion.

Exercises 6.2-6
Show that the worst-case running time of MAX-HEAPIFY on a heap of size n is Ω(lg n).
(Hint: For a heap with n nodes, give node values that cause MAX-HEAPIFY to be called
recursively at every node on a path from the root down to a leaf.)

6.3 Building a heap
We can use the procedure MAX-HEAPIFY in a bottom-up manner to convert an array A[1
n], where n = length[A], into a max-heap. By Exercise 6.1-7, the elements in the subarray
A[(⌊n/2⌋+1) n] are all leaves of the tree, and so each is a 1-element heap to begin with. The
procedure BUILD-MAX-HEAP goes through the remaining nodes of the tree and runs MAXHEAPIFY on each one.
BUILD-MAX-HEAP(A)
1 heap-size[A] ← length[A]
2
3

for i ← ⌊length[A]/2⌋ downto 1
do MAX-HEAPIFY(A, i)

Figure 6.3 shows an example of the action of BUILD-MAX-HEAP.

