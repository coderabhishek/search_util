•

•

•

•

complicated implementation yields O(lg n) worst-case time bounds. Dynamic trees are
used in some of the asymptotically fastest network-flow algorithms.
Splay trees, developed by Sleator and Tarjan [282] and discussed by Tarjan [292], are
a form of binary search tree on which the standard search-tree operations run in O(lg
n) amortized time. One application of splay trees simplifies dynamic trees.
Persistent data structures allow queries, and sometimes updates as well, on past
versions of a data structure. Driscoll, Sarnak, Sleator, and Tarjan [82] present
techniques for making linked data structures persistent with only a small time and
space cost. Problem 13-1 gives a simple example of a persistent dynamic set.
Several data structures allow a faster implementation of dictionary operations
(INSERT, DELETE, and SEARCH) for a restricted universe of keys. By taking
advantage of these restrictions, they are able to achieve better worst-case asymptotic
running times than comparison-based data structures. A data structure invented by van
Emde Boas [301] supports the operations MINIMUM, MAXIMUM, INSERT,
DELETE, SEARCH, EXTRACT-MIN, EXTRACT-MAX, PREDECESSOR, and
SUCCESSOR in worst-case time O(lg lg n), subject to the restriction that the universe
of keys is the set {1, 2,..., n}. Fredman and Willard introduced fusion trees [99],
which were the first data structure to allow faster dictionary operations when the
universe is restricted to integers. They showed how to implement these operations in
O(lg n/ lg lg n) time. Several subsequent data structures, including exponential search
trees [16], have also given improved bounds on some or all of the dictionary
operations and are mentioned in the chapter notes throughout this book.
Dynamic graph data structures support various queries while allowing the structure
of a graph to change through operations that insert or delete vertices or edges.
Examples of the queries that are supported include vertex connectivity [144], edge
connectivity, minimum spanning trees [143], biconnectivity, and transitive closure
[142].

Chapter notes throughout this book mention additional data structures.
[1]

As in Problem 10-2, we have defined a mergeable heap to support MINIMUM and
EXTRACT-MIN, and so we can also refer to it as a mergeable min-heap. Alternatively, if it
supported MAXIMUM and EXTRACT-MAX, it would be a mergeable max-heap. Unless
we specify otherwise, mergeable heaps will be by default mergeable min-heaps.

Chapter 18: B-Trees
Overview
B-trees are balanced search trees designed to work well on magnetic disks or other directaccess secondary storage devices. B-trees are similar to red-black trees (Chapter 13), but they
are better at minimizing disk I/O operations. Many database systems use B-trees, or variants
of B-trees, to store information.
B-trees differ from red-black trees in that B-tree nodes may have many children, from a
handful to thousands. That is, the "branching factor" of a B-tree can be quite large, although it
is usually determined by characteristics of the disk unit used. B-trees are similar to red-black
trees in that every n-node B-tree has height O(lg n), although the height of a B-tree can be
considerably less than that of a red-black tree because its branching factor can be much larger.

