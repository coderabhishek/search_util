The queries SUCCESSOR and PREDECESSOR are often extended to sets with non-distinct
keys. For a set on n keys, the normal presumption is that a call to MINIMUM followed by n 1 calls to SUCCESSOR enumerates the elements in the set in sorted order.
The time taken to execute a set operation is usually measured in terms of the size of the set
given as one of its arguments. For example, Chapter 13 describes a data structure that can
support any of the operations listed above on a set of size n in time O(lg n).

Overview of Part III
Chapters 10–14 describe several data structures that can be used to implement dynamic sets;
many of these will be used later to construct efficient algorithms for a variety of problems.
Another important data structure—the heap—has already been introduced in Chapter 6.
Chapter 10 presents the essentials of working with simple data structures such as stacks,
queues, linked lists, and rooted trees. It also shows how objects and pointers can be
implemented in programming environments that do not support them as primitives. Much of
this material should be familiar to anyone who has taken an introductory programming
course.
Chapter 11 introduces hash tables, which support the dictionary operations INSERT,
DELETE, and SEARCH. In the worst case, hashing requires Θ(n) time to perform a SEARCH
operation, but the expected time for hash-table operations is O(1). The analysis of hashing
relies on probability, but most of the chapter requires no background in the subject.
Binary search trees, which are covered in Chapter 12, support all the dynamic-set operations
listed above. In the worst case, each operation takes Θ(n) time on a tree with n elements, but
on a randomly built binary search tree, the expected time for each operation is O(lg n). Binary
search trees serve as the basis for many other data structures.
Red-black trees, a variant of binary search trees, are introduced in Chapter 13. Unlike
ordinary binary search trees, red-black trees are guaranteed to perform well: operations take
O(lg n) time in the worst case. A red-black tree is a balanced search tree; Chapter 18 presents
another kind of balanced search tree, called a B-tree. Although the mechanics of red-black
trees are somewhat intricate, you can glean most of their properties from the chapter without
studying the mechanics in detail. Nevertheless, walking through the code can be quite
instructive.
In Chapter 14, we show how to augment red-black trees to support operations other than the
basic ones listed above. First, we augment them so that we can dynamically maintain order
statistics for a set of keys. Then, we augment them in a different way to maintain intervals of
real numbers.

Chapter 10: Elementary Data Structures
In this chapter, we examine the representation of dynamic sets by simple data structures that
use pointers. Although many complex data structures can be fashioned using pointers, we
present only the redimentary ones: stacks, queues, linked lists, and rooted trees. We also
discuss a method by which objects and pointers can be synthesized from arrays.

