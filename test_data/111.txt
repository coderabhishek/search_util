We introduced two algorithms that sort n real numbers in Chapter 2. Insertion sort takes Θ(n2)
time in the worst case. Because its inner loops are tight, however, it is a fast in-place sorting
algorithm for small input sizes. (Recall that a sorting algorithm sorts in place if only a
constant number of elements of the input array are ever stored outside the array.) Merge sort
has a better asymptotic running time, Θ(n lg n), but the MERGE procedure it uses does not
operate in place.
In this part, we shall introduce two more algorithms that sort arbitrary real numbers. Heapsort,
presented in Chapter 6, sorts n numbers in place in O(n lg n) time. It uses an important data
structure, called a heap, with which we can also implement a priority queue.
Quicksort, in Chapter 7, also sorts n numbers in place, but its worst-case running time is
Θ(n2). Its average-case running time is Θ(n lg n), though, and it generally outperforms
heapsort in practice. Like insertion sort, quicksort has tight code, so the hidden constant factor
in its running time is small. It is a popular algorithm for sorting large input arrays.
Insertion sort, merge sort, heapsort, and quicksort are all comparison sorts: they determine the
sorted order of an input array by comparing elements. Chapter 8 begins by introducing the
decision-tree model in order to study the performance limitations of comparison sorts. Using
this model, we prove a lower bound of Ω(n lg n) on the worst-case running time of any
comparison sort on n inputs, thus showing that heapsort and merge sort are asymptotically
optimal comparison sorts.
Chapter 8 then goes on to show that we can beat this lower bound of Ω(n lg n) if we can
gather information about the sorted order of the input by means other than comparing
elements. The counting sort algorithm, for example, assumes that the input numbers are in the
set {1, 2, ..., k}. By using array indexing as a tool for determining relative order, counting sort
can sort n numbers in Θ(k + n) time. Thus, when k = O(n), counting sort runs in time that is
linear in the size of the input array. A related algorithm, radix sort, can be used to extend the
range of counting sort. If there are n integers to sort, each integer has d digits, and each digit
is in the set {1, 2, ..., k}, then radix sort can sort the numbers in Θ(d(n + k)) time. When d is a
constant and k is O(n), radix sort runs in linear time. A third algorithm, bucket sort, requires
knowledge of the probabilistic distribution of numbers in the input array. It can sort n real
numbers uniformly distributed in the half-open interval [0, 1) in average-case O(n) time.

Order statistics
The ith order statistic of a set of n numbers is the ith smallest number in the set. One can, of
course, select the ith order statistic by sorting the input and indexing the ith element of the
output. With no assumptions about the input distribution, this method runs in Ω(n lg n) time,
as the lower bound proved in Chapter 8 shows.
In Chapter 9, we show that we can find the ith smallest element in O(n) time, even when the
elements are arbitrary real numbers. We present an algorithm with tight pseudocode that runs
in Θ (n2) time in the worst case, but linear time on average. We also give a more complicated
algorithm that runs in O(n) worst-case time.

Background

