Figure 10.9: The representation of a binary tree T. Each node x has the fields p[x] (top), left[x]
(lower left), and right[x] (lower right). The key fields are not shown.
Rooted trees with unbounded branching
The scheme for representing a binary tree can be extended to any class of trees in which the
number of children of each node is at most some constant k: we replace the left and right
fields by child1, child2,..., childk. This scheme no longer works when the number of children
of a node is unbounded, since we do not know how many fields (arrays in the multiple-array
representation) to allocate in advance. Moreover, even if the number of children k is bounded
by a large constant but most nodes have a small number of children, we may waste a lot of
memory.
Fortunately, there is a clever scheme for using binary trees to represent trees with arbitrary
numbers of children. It has the advantage of using only O(n) space for any n-node rooted tree.
The left-child, right-sibling representation is shown in Figure 10.10. As before, each node
contains a parent pointer p, and root[T] points to the root of tree T . Instead of having a
pointer to each of its children, however, each node x has only two pointers:

Figure 10.10: The left-child, right-sibling representation of a tree T . Each node x has fields
p[x] (top), left-child[x] (lower left), and right-sibling[x] (lower right). Keys are not shown.
1. left-child[x] points to the leftmost child of node x, and
2. right-sibling[x] points to the sibling of x immediately to the right.
If node x has no children, then left-child[x] = NIL, and if node x is the rightmost child of its
parent, then right-sibling[x] = NIL.
Other tree representations

