Figure 15.6 shows the tables produced by LCS-LENGTH on the sequences X = A, B, C, B,
D, A, B and Y = B, D, C, A, B, A . The running time of the procedure is O(mn), since
each table entry takes O(1) time to compute.

Figure 15.6: The c and b tables computed by LCS-LENGTH on the sequences X = A, B, C,
B, D, A, B and Y = B, D, C, A, B, A . The square in row i and column j contains the value
of c[i, j] and the appropriate arrow for the value of b[i, j]. The entry 4 in c[7, 6]—the lower
right-hand corner of the table—is the length of an LCS B, C, B, A of X and Y . For i, j > 0,
entry c[i, j] depends only on whether xi = yj and the values in entries c[i - 1, j], c[i, j - 1], and
c[i - 1, j - 1], which are computed before c[i, j]. To reconstruct the elements of an LCS, follow
the b[i, j] arrows from the lower right-hand corner; the path is shaded. Each " " on the path
corresponds to an entry (highlighted) for which xi = yj is a member of an LCS.
Step 4: Constructing an LCS
The b table returned by LCS-LENGTH can be used to quickly construct an LCS of X = x1,
x2, ..., xm and Y = y1, y2, ..., yn . We simply begin at b[m, n] and trace through the table
following the arrows. Whenever we encounter a " " in entry b[i, j], it implies that xi = yj is an
element of the LCS. The elements of the LCS are encountered in reverse order by this
method. The following recursive procedure prints out an LCS of X and Y in the proper,
forward order. The initial invocation is PRINT-LCS(b, X, length[X], length[Y]).
PRINT-LCS(b, X, i, j)
1 if i = 0 or j = 0
2
then return
3 if b[i, j] = " "
4
then PRINT-LCS(b, X, i - 1, j - 1)
5
print xi
6 elseif b[i, j] = "↑"
7
then PRINT-LCS(b, X, i - 1, j)
8 else PRINT-LCS(b, X, i, j - 1)

