Heapsort and merge sort are asymptotically optimal comparison sorts.
Proof The O(n lg n) upper bounds on the running times for heapsort and merge sort match the
Ω(n lg n) worst-case lower bound from Theorem 8.1.

Exercises 8.1-1
What is the smallest possible depth of a leaf in a decision tree for a comparison sort?

Exercises 8.1-2
Obtain asymptotically tight bounds on lg(n!) without using Stirling's approximation. Instead,
evaluate the summation
using techniques from Section A.2.

Exercises 8.1-3
Show that there is no comparison sort whose running time is linear for at least half of the n!
inputs of length n. What about a fraction of 1/n of the inputs of length n? What about a
fraction 1/2n?

Exercises 8.1-4
You are given a sequence of n elements to sort. The input sequence consists of n/k
subsequences, each containing k elements. The elements in a given subsequence are all
smaller than the elements in the succeeding subsequence and larger than the elements in the
preceding subsequence. Thus, all that is needed to sort the whole sequence of length n is to
sort the k elements in each of the n/k subsequences. Show an Ω(n lg k) lower bound on the
number of comparisons needed to solve this variant of the sorting problem. (Hint: It is not
rigorous to simply combine the lower bounds for the individual subsequences.)

8.2 Counting sort
Counting sort assumes that each of the n input elements is an integer in the range 0 to k, for
some integer k. When k = O(n), the sort runs in Θ(n) time.
The basic idea of counting sort is to determine, for each input element x, the number of
elements less than x. This information can be used to place element x directly into its position
in the output array. For example, if there are 17 elements less than x, then x belongs in output

