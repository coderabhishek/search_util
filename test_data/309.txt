The e[i, j] values give the expected search costs in optimal binary search trees. To help us
keep track of the structure of optimal binary search trees, we define root[i, j], for 1 ≤ i ≤ j ≤ n,
to be the index r for which kr is the root of an optimal binary search tree containing keys ki, ...,
kj. Although we will see how to compute the values of root[i, j], we leave the construction of
the optimal binary search tree from these values as Exercise 15.5-1.
Step 3: Computing the expected search cost of an optimal binary search tree
At this point, you may have noticed some similarities between our characterizations of
optimal binary search trees and matrix-chain multiplication. For both problem domains, our
subproblems consist of contiguous index subranges. A direct, recursive implementation of
equation (15.19) would be as inefficient as a direct, recursive matrix-chain multiplication
algorithm. Instead, we store the e[i, j] values in a table e[1 n + 1, 0 n]. The first index
needs to run to n + 1 rather than n because in order to have a subtree containing only the
dummy key dn, we will need to compute and store e[n + 1, n]. The second index needs to start
from 0 because in order to have a subtree containing only the dummy key d0, we will need to
compute and store e[1, 0]. We will use only the entries e[i, j] for which j ≥ i - 1. We also use a
table root[i, j], for recording the root of the subtree containing keys ki, ..., kj. This table uses
only the entries for which 1 ≤ i ≤ j ≤ n.
We will need one other table for efficiency. Rather than compute the value of w(i, j) from
scratch every time we are computing e[i, j]—which would take Θ(j - i) additions—we store
these values in a table w[1 n + 1, 0 n]. For the base case, we compute w[i, i - 1] = qi-1 for
1 ≤ i ≤ n. For j ≥ i, we compute
(15.20)
Thus, we can compute the Θ(n2) values of w[i, j] in Θ(1) time each.
The pseudocode that follows takes as inputs the probabilities p1, ..., pn and q0, ..., qn and the
size n, and it returns the tables e and root.
OPTIMAL-BST(p, q, n)
1 for i ← 1 to n + 1
2
do e[i, i - 1] ← qi-1
3
w[i, i - 1] ← qi-1
4 for l ← 1 to n
5
do for i ← 1 to n - l + 1
6
do j ← i + l - 1
7
e[i, j] ← ∞
8
w[i, j] ← w[i, j - 1] +
9
for r ← i to j
10
do t ← e[i, r - 1]
11
if t < e[i, j]
12
then e[i, j]
13
root[i,
14 return e and root

pj + qj
+ e[r + 1, j] + w[i, j]
← t
j] ← r

From the description above and the similarity to the MATRIX-CHAIN-ORDER procedure in
Section 15.2, the operation of this procedure should be fairly straightforward. The for loop of
lines 1–3 initializes the values of e[i, i - 1] and w[i, i - 1]. The for loop of lines 4–13 then uses
the recurrences (15.19) and (15.20) to compute e[i, j] and w[i, j] for all 1 ≤ i ≤ j ≤ n. In the

