16.5

A task-scheduling problem

An interesting problem that can be solved using matroids is the problem of optimally
scheduling unit-time tasks on a single processor, where each task has a deadline,
along with a penalty that must be paid if the deadline is missed. The problem looks
complicated, but it can be solved in a surprisingly simple manner using a greedy
algorithm.
A unit-time task is a job, such as a program to be run on a computer, that requires
exactly one unit of time to complete. Given a finite set S of unit-time tasks, a schedule
for S is a permutation of S specifying the order in which these tasks are to be
performed. The first task in the schedule begins at time 0 and finishes at time 1, the
second task begins at time 1 and finishes at time 2, and so on.
The problem of scheduling unit-time tasks with deadlines and penalties for a
single processor has the following inputs:
a set S = {a1, a2, ..., an} of n unit-time tasks;
a set of n integer deadlines d1, d2, ..., dn, such that each di satisfies 1 ≤ di ≤ n
and task ai is supposed to finish by time di; and
a set of n nonnegative weights or penalties w1, w2, ..., wn, such that we incur a
penalty of wi if task ai is not finished by time di and we incur no penalty if a task
finishes by its deadline.
We are asked to find a schedule for S that minimizes the total penalty incurred for
missed deadlines.
Consider a given schedule. We say that a task is late in this schedule if it finishes after
its deadline. Otherwise, the task is early in the schedule. An arbitrary schedule can
always be put into early-first form, in which the early tasks precede the late tasks. To
see this, note that if some early task ai follows some late task aj, then we can switch the
positions of ai and aj, and ai will still be early and aj will still be late.
We similarly claim that an arbitrary schedule can always be put into canonical form, in
which the early tasks precede the late tasks and the early tasks are scheduled in order
of monotonically increasing deadlines. To do so, we put the schedule into early-first
form. Then, as long as there are two early tasks ai and aj finishing at respective times k
and k + 1 in the schedule such that dj < di, we swap the positions of ai and aj. Since aj
is early before the swap, k + 1 ≤ dj. Therefore, k + 1 < di, and so ai is still early after
the swap. Task aj is moved earlier in the schedule, so it also still early after the swap.
The search for an optimal schedule thus reduces to finding a set A of tasks that are to
be early in the optimal schedule. Once A is determined, we can create the actual
schedule by listing the elements of A in order of monotonically increasing deadline, then
listing the late tasks (i.e., S - A) in any order, producing a canonical ordering of the
optimal schedule.
We say that a set A of tasks is independent if there exists a schedule for these tasks
such that no tasks are late. Clearly, the set of early tasks for a schedule forms an
independent set of tasks. Letℓ denote the set of all independent sets of tasks.
Consider the problem of determining whether a given set A of tasks is independent. For
t = 0, 1, 2, ..., n, let Nt (A) denote the number of tasks in A whose deadline is t or earlier.
Note that N0(A) = 0 for any set A.
Lemma 16.12
For any set of tasks A, the following statements are equivalent.
1. The set A is independent.
2. For t = 0, 1, 2, ..., n, we have Nt (A) ≤ t.
3. If the tasks in A are scheduled in order of monotonically increasing
deadlines, then no task is late.
Proof Clearly, if Nt (A) >; t for some t, then there is no way to make a schedule with no
late tasks for set A, because there are more than t tasks to finish before time t. Therefore,
(1) implies (2). If (2) holds, then (3) must follow: there is no way to "get stuck" when

