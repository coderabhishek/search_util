(the arrow between them points left), it is rejected. Otherwise (the arrow points directly up or
to the right), it is selected. The last recursive call, RECURSIVE-ACTIVITY-SELECTOR(s, f,
11, 12), returns Ø. The resulting set of selected activities is {a1, a4, a8, a11}.
Assuming that the activities have already been sorted by finish times, the running time of the
call RECURSIVE-ACTIVITY-SELECTOR(s, f, 0, n + 1) is Θ(n), which we can see as
follows. Over all recursive calls, each activity is examined exactly once in the while loop test
of line 2. In particular, activity ak is examined in the last call made in which i < k.
An iterative greedy algorithm
We easily can convert our recursive procedure to an iterative one. The procedure
RECURSIVE-ACTIVITY-SELECTOR is almost "tail recursive" (see Problem 7-4): it ends
with a recursive call to itself followed by a union operation. It is usually a straightforward task
to transform a tail-recursive procedure to an iterative form; in fact, some compilers for certain
programming languages perform this task automatically. As written, RECURSIVEACTIVITY-SELECTOR works for any subproblem Sij, but we have seen that we need to
consider only subproblems for which j = n + 1, i.e., subproblems that consist of the last
activities to finish.
The procedure GREEDY-ACTIVITY-SELECTOR is an iterative version of the procedure
RECURSIVE-ACTIVITY-SELECTOR. It also assumes that the input activities are ordered
by monotonically increasing finish time. It collects selected activities into a set A and returns
this set when it is done.
GREEDY-ACTIVITY-SELECTOR(s, f)
1 n ← length[s]
2 A ← {a1}
3 i ← 1
4 for m ← 2 to n
5
do if sm ≥ fi
6
then A ← A
{am}
7
i ← m
8 return A

The procedure works as follows. The variable i indexes the most recent addition to A,
corresponding to the activity ai in the recursive version. Since the activities are considered in
order of monotonically increasing finish time, fi is always the maximum finish time of any
activity in A. That is,
(16.4)
Lines 2–3 select activity a1, initialize A to contain just this activity, and initialize i to index
this activity. The for loop of lines 4–7 finds the earliest activity to finish in Si.n+1. The loop
considers each activity am in turn and adds am to A if it is compatible with all previously
selected activities; such an activity is the earliest to finish in Si.n+1. To see if activity am is
compatible with every activity currently in A, it suffices by equation (16.4) to check (line 5)
that its start time sm is not earlier than the finish time fi of the activity most recently added to
A. If activity am is compatible, then lines 6–7 add activity am to A and set i to m. The set A
returned by the call GREEDY-ACTIVITY-SELECTOR(s, f) is precisely the set returned by
the call RECURSIVE-ACTIVITY-SELECTOR(s, f, 0, n + 1).

