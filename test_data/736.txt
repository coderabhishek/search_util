[246] discuss multdimensional Fourier Transform and their use in image processing, and
books by Tolimieri, An, and Lu [300] and Van Loan [303] discuss the mathematics of
multidimensional Fast Fourier Transforms.
Cooley and Tukey [68] are widely credited with devising the FFT in the 1960's. The FFT had
in fact been discovered many times previously, but its importance was not fully realized
before the advent of modern digitial computers. Although Press, Flannery, Teukolsky, and
Vetterling attribute the origins of the method of Runge and König in 1924, an article by
Heideman, Johnson, and Burrus [141] traces the history of the FFT as far back as C. F. Gauss
in 1805.

Chapter 31: Number-Theoretic Algorithms
Number theory was once viewed as a beautiful but largely useless subject in pure
mathematics. Today number-theoretic algorithms are used widely, due in part to the invention
of cryptographic schemes based on large prime numbers. The feasibility of these schemes
rests on our ability to find large primes easily, while their security rests on our inability to
factor the product of large primes. This chapter presents some of the number theory and
associated algorithms that underlie such applications.
Section 31.1 introduces basic concepts of number theory, such as divisibility, modular
equivalence, and unique factorization. Section 31.2 studies one of the world's oldest
algorithms: Euclid's algorithm for computing the greatest common divisor of two integers.
Section 31.3 reviews concepts of modular arithmetic. Section 31.4 then studies the set of
multiples of a given number a, modulo n, and shows how to find all solutions to the equation
ax ≡ b (mod n) by using Euclid's algorithm. The Chinese remainder theorem is presented in
Section 31.5. Section 31.6 considers powers of a given number a, modulo n, and presents a
repeated-squaring algorithm for efficiently computing ab mod n, given a, b, and n. This
operation is at the heart of efficient primality testing and of much modern cryptography.
Section 31.7 then describes the RSA public-key cryptosystem. Section 31.8 examines a
randomized primality test that can be used to find large primes efficiently, an essential task in
creating keys for the RSA cryptosystem. Finally, Section 31.9 reviews a simple but effective
heuristic for factoring small integers. It is a curious fact that factoring is one problem people
may wish to be intractable, since the security of RSA depends on the difficulty of factoring
large integers.
Size of inputs and cost of arithmetic computations
Because we shall be working with large integers, we need to adjust how we think about the
size of an input and about the cost of elementary arithmetic operations.
In this chapter, a "large input" typically means an input containing "large integers" rather than
an input containing "many integers" (as for sorting). Thus, we shall measure the size of an
input in terms of the number of bits required to represent that input, not just the number of
integers in the input. An algorithm with integer inputs a1, a2, ..., ak is a polynomial-time
algorithm if it runs in time polynomial in lg a1, lg a2, ..., lg ak, that is, polynomial in the
lengths of its binary-encoded inputs.

