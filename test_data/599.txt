combinational circuits or parallel computers. Others cover specialized domains such as
computational geometry or number theory. The last two chapters discuss some of the known
limitations to the design of efficient algorithms and introduce techniques for coping with
those limitations.
Chapter 27 presents a parallel model of computation: comparison networks. Roughly
speaking, a comparison network is an algorithm that allows many comparisons to be made
simultaneously. This chapter shows how to build a comparison network that can sort n
numbers in O(lg2 n) time.
Chapter 28 studies efficient algorithms for operating on matrices. After examining some basic
matrix properties, it explores Strassen's algorithm, which can multiply two n Ã— n matrices in
O(n2.81) time. It then presents two general methods-LU decomposition and LUP
decomposition-for solving linear equations by Gaussian elimination in O(n3) time. It also
shows that matrix inversion and matrix multiplication can be performed equally fast. The
chapter concludes by showing how a least-squares approximate solution can be computed
when a set of linear equations has no exact solution.
Chapter 29 studies linear programming, in which we wish to maximize or minimize an
objective, given limited resources and competing constraints. Linear programming arises in a
variety of practical application areas. This chapter covers the formulation and solution of
linear programs. The solution method covered is the simplex algorithm, which is the oldest
algorithm for linear programming. In contrast to many algorithms in this book, the simplex
algorithm does not run in polynomial time in the worst case, but it is fairly efficient and
widely used in practice.
Chapter 30 studies operations on polynomials and shows that a well-known signal-processing
technique-the Fast Fourier Transform (FFT)-can be used to multiply two degree-n
polynomials in O(n lg n) time. It also investigates efficient implementations of the FFT,
including a parallel circuit.
Chapter 31 presents number-theoretic algorithms. After a review of elementary number
theory, it presents Euclid's algorithm for computing greatest common divisors. Algorithms for
solving modular linear equations and for raising one number to a power modulo another
number are presented next. Then we see an important application of number-theoretic
algorithms: the RSA public-key cryptosystem. This cryptosystem not only can be used to
encrypt messages so that an adversary cannot read them, it also can be used to provide digital
signatures. The chapter then presents the Miller-Rabin randomized primality test, which can
be used to find large primes efficiently-an essential requirement for the RSA system. Finally,
the chapter covers Pollard's "rho" heuristic for factoring integers and discusses the state of the
art of integer factorization.
Chapter 32 studies the problem of finding all occurrences of a given pattern string in a given
text string, a problem that arises frequently in text-editing programs. After examining the
naive approach, the chapter presents an elegant approach due to Rabin and Karp. Then, after
showing an efficient solution based on finite automata, the chapter presents the Knuth-MorrisPratt algorithm, which achieves efficiency by cleverly preprocessing the pattern.
Computational geometry is the topic of Chapter 33. After discussing basic primitives of
computational geometry, the chapter shows how a "sweeping" method can efficiently

