Chapter notes
There are many excellent texts on the general topic of algorithms, including those by Aho,
Hopcroft, and Ullman [5, 6], Baase and Van Gelder [26], Brassard and Bratley [46, 47],
Goodrich and Tamassia [128], Horowitz, Sahni, and Rajasekaran [158], Kingston [179],
Knuth [182, 183, 185], Kozen [193], Manber [210], Mehlhorn [217, 218, 219], Purdom and
Brown [252], Reingold, Nievergelt, and Deo [257], Sedgewick [269], Skiena [280], and Wilf
[315]. Some of the more practical aspects of algorithm design are discussed by Bentley [39,
40] and Gonnet [126]. Surveys of the field of algorithms can also be found in the Handbook
of Theoretical Computer Science, Volume A [302] and the CRC Handbook on Algorithms
and Theory of Computation [24]. Overviews of the algorithms used in computational biology
can be found in textbooks by Gusfield [136], Pevzner [240], Setubal and Medinas [272], and
Waterman [309].

Chapter 2: Getting Started
This chapter will familiarize you with the framework we shall use throughout the book to
think about the design and analysis of algorithms. It is self-contained, but it does include
several references to material that will be introduced in Chapters 3 and 4. (It also contains
several summations, which Appendix A shows how to solve.)
We begin by examining the insertion sort algorithm to solve the sorting problem introduced in
Chapter 1. We define a "pseudocode" that should be familiar to readers who have done
computer programming and use it to show how we shall specify our algorithms. Having
specified the algorithm, we then argue that it correctly sorts and we analyze its running time.
The analysis introduces a notation that focuses on how that time increases with the number of
items to be sorted. Following our discussion of insertion sort, we introduce the divide-andconquer approach to the design of algorithms and use it to develop an algorithm called merge
sort. We end with an analysis of merge sort's running time.

2.1 Insertion sort
Our first algorithm, insertion sort, solves the sorting problem introduced in Chapter 1:
•
•

Input: A sequence of n numbers a1, a2, . . .,an .
Output: A permutation (reordering)
of the input sequence such that
.

The numbers that we wish to sort are also known as the keys.
In this book, we shall typically describe algorithms as programs written in a pseudocode that
is similar in many respects to C, Pascal, or Java. If you have been introduced to any of these
languages, you should have little trouble reading our algorithms. What separates pseudocode
from "real" code is that in pseudocode, we employ whatever expressive method is most clear
and concise to specify a given algorithm. Sometimes, the clearest method is English, so do not
be surprised if you come across an English phrase or sentence embedded within a section of
"real" code. Another difference between pseudocode and real code is that pseudocode is not
typically concerned with issues of software engineering. Issues of data abstraction,

