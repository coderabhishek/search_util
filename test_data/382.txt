Figure 18.7: Inserting keys into a B-tree. The minimum degree t for this B-tree is 3, so a node
can hold at most 5 keys. Nodes that are modified by the insertion process are lightly shaded.
(a) The initial tree for this example. (b) The result of inserting B into the initial tree; this is a
simple insertion into a leaf node. (c) The result of inserting Q into the previous tree. The node
RSTUV is split into two nodes containing RS and UV, the key T is moved up to the root, and Q
is inserted in the leftmost of the two halves (the RS node). (d) The result of inserting L into the
previous tree. The root is split right away, since it is full, and the B-tree grows in height by
one. Then L is inserted into the leaf containing JK. (e) The result of inserting F into the
previous tree. The node ABCDE is split before F is inserted into the rightmost of the two
halves (the DE node).
The number of disk accesses performed by B-TREE-INSERT is O(h) for a B-tree of height h,
since only O(1) DISK-READ and DISK-WRITE operations are performed between calls to
B-TREE-INSERT-NONFULL. The total CPU time used is O(th) = O(t logt n). Since BTREE-INSERT-NONFULL is tail-recursive, it can be alternatively implemented as a while
loop, demonstrating that the number of pages that need to be in main memory at any time is
O(1).
Exercises 18.2-1
Show the results of inserting the keys
F, S, Q, K, C, L, H, T, V, W, M, R, N, P, A, B, X, Y, D, Z, E
in order into an empty B-tree with minimum degree 2. Only draw the configurations of the
tree just before some node must split, and also draw the final configuration.

