Proof Since the push was nonsaturating, the amount of flow df(u, v) actually pushed must
equal e[u] prior to the push. Since e[u] is reduced by this amount, it becomes 0 after the push.

The relabel operation

The basic operation RELABEL (u) applies if u is overflowing and if h[u] ≤ h[v] for all edges
(u, v) Ef. In other words, we can relabel an overflowing vertex u if for every vertex v for
which there is residual capacity from u to v, flow cannot be pushed from u to v because v is
not downhill from u. (Recall that by definition, neither the source s nor the sink t can be
overflowing, so neither s nor t can be relabeled.)
RELABEL(u)
1 ▹ Applies when: u is overflowing and for all v
we have h[u] ≤ h[v].

V such that (u, v)

Ef,

2 ▹ Action: Increase the height of u.
3 h[u] ← 1 + min {h[v] : (u, v)
Ef}

When we call the operation RELABEL(u), we say that vertex u is relabeled. Note that when u
is relabeled, Ef must contain at least one edge that leaves u, so that the minimization in the
code is over a nonempty set. This property follows from the assumption that u is overflowing.
Since e[u] > 0, we have e[u] = f(V, u) > 0, and hence there must be at least one vertex v such
that f[v, u] > 0. But then,
cf(u, v) = c(u, v) - f[u, v]
= c(u, v) + f[v, u]
> 0,
which implies that (u, v) Ef. The operation RELABEL(u) thus gives u the greatest height
allowed by the constraints on height functions.
The generic algorithm
The generic push-relabel algorithm uses the following subroutine to create an initial preflow
in the flow network.
INITIALIZE-PREFLOW(G, s)
1 for each vertex u
V[G]
2
do h[u] ← 0
3
e[u] ← 0
4 for each edge (u, v)
E[G]
5
do f[u, v] ← 0
6
f[v, u] ← 0
7 h[s] ← |V[G]|
8 for each vertex u
Adj[s]
9
do f[s, u] ← c(s, u)
10
f[u, s] ← -c(s, u)
11
e[u] ← c(s, u)
12
e[s] ← e[s] - c(s, u)

