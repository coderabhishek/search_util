lines 4-9, we have that k = π[q - 1]. This condition is enforced by lines 2 and 3 when the loop
is first entered, and it remains true in each successive iteration because of line 9. Lines 5-8
adjust k so that it now becomes the correct value of π[q]. The loop on lines 5-6 searches
through all values k π*[q - 1] until one is found for which P[k + 1] = P[q]; at that point, k is
the largest value in the set Eq-1, so that, by Corollary 32.7, we can set π[q] to k + 1. If no such
k is found, k = 0 in line 7. If P[1] = P[q], then we should set both k and π[q] to 1; otherwise
we should leave k alone and set π[q] to 0. Lines 7-9 set k and π[q] correctly in either case.
This completes our proof of the correctness of COMPUTE-PREFIX-FUNCTION.
Correctness of the KMP algorithm
The procedure KMP-MATCHER can be viewed as a reimplementation of the procedure
FINITE-AUTOMATON-MATCHER. Specifically, we shall prove that the code in lines 6-9
of KMP-MATCHER is equivalent to line 4 of FINITE-AUTOMATON-MATCHER, which
sets q to δ(q, T[i]). Instead of using a stored value of δ(q, T[i]), however, this value is
recomputed as necessary from p. Once we have argued that KMP-MATCHER simulates the
behavior of FINITE-AUTOMATON-MATCHER, the correctness of KMP-MATCHER
follows from the correctness of FINITE-AUTOMATON-MATCHER (though we shall see in
a moment why line 12 in KMP-MATCHER is necessary).
The correctness of KMP-MATCHER follows from the claim that we must have either δ(q,
T[i]) = 0 or δ(q, T[i]) - 1

π*[q]. To check this claim, let k = δ(q, T[i]). Then, Pk ⊐ PqT[i] by

the definitions of δ and σ. Therefore, either k = 0 or else k ≥ 1 and Pk-1 ⊐ Pq by dropping the
last character from both Pk and PqT[i] (in which case k - 1 π*[q]). Therefore, either k = 0 or
k - 1 π*[q], proving the claim.
The claim is used as follows. Let q′ denote the value of q when line 6 is entered. We use the
equivalence π*[q] = {k : k < q and Pk ⊐ Pq} from Lemma 32.5 to justify the iteration q ←
π[q] that enumerates the elements of {k : Pk ⊐ Pq′}.
Lines 6-9 determine δ(q′, T[i]) by examining the elements of π*[q′] in decreasing order. The
code uses the claim to begin with q = φ(Ti-1) = σ(Ti-1) and perform the iteration q ← π[q] until
a q is found such that q = 0 or P[q + 1] = T[i]. In the former case, δ(q′, T[i]) = 0; in the latter
case, q is the maximum element in Eq′, so that δ(q′, T[i]) = q + 1 by Corollary 32.7.
Line 12 is necessary in KMP-MATCHER to avoid a possible reference to P[m + 1] on line 6
after an occurrence of P has been found. (The argument that q = σ(Ti-1) upon the next
execution of line 6 remains valid by the hint given in Exercise 32.4-6: δ(m, a) = δ(π[m], a) or,
equivalently, σ(Pa) = σ(Pπ[m]a) for any a Σ.) The remaining argument for the correctness of
the Knuth-Morris-Pratt algorithm follows from the correctness of FINITE-AUTOMATONMATCHER, since we now see that KMP-MATCHER simulates the behavior of FINITEAUTOMATON-MATCHER.
Exercises 32.4-1
Compute the prefix function π for the pattern ababbabbabbababbabb when the alphabet is Σ =
{a, b}.

