In other words, by reducing a known NP-complete language L′ to L, we implicitly reduce
every language in NP to L. Thus, Lemma 34.8 gives us a method for proving that a language
L is NP-complete:
1. Prove L NP.
2. Select a known NP-complete language L′.
3. Describe an algorithm that computes a function f mapping every instance x {0, 1}*
of L′ to an instance f(x) of L.
4. Prove that the function f satisfies x L′ if and only if f (x) L for all x {0, 1}*.
5. Prove that the algorithm computing f runs in polynomial time.
(Steps 2-5 show that L is NP-hard.) This methodology of reducing from a single known NPcomplete language is far simpler than the more complicated process of showing directly how
to reduce from every language in NP. Proving CIRCUIT-SAT NPC has given us a "foot in
the door." Knowing that the circuit-satisfiability problem is NP-complete now allows us to
prove much more easily that other problems are NP-complete. Moreover, as we develop a
catalog of known NP-complete problems, we will have more and more choices for languages
from which to reduce.
Formula satisfiability
We illustrate the reduction methodology by giving an NP-completeness proof for the problem
of determining whether a boolean formula, not a circuit, is satisfiable. This problem has the
historical honor of being the first problem ever shown to be NP-complete.
We formulate the (formula) satisfiability problem in terms of the language SAT as follows.
An instance of SAT is a boolean formula φ composed of
1. n boolean variables: x1, x2, ..., xn;
2. m boolean connectives: any boolean function with one or two inputs and one output,
such as (AND), (OR), ¬ (NOT), → (implication), ↔ (if and only if); and
3. parentheses. (Without loss of generality, we assume that there are no redundant
parentheses, i.e., there is at most one pair of parentheses per boolean connective.)
It is easy to encode a boolean formula φ in a length that is polynomial in n + m. As in boolean
combinational circuits, a truth assignment for a boolean formula φ is a set of values for the
variables of φ, and a satisfying assignment is a truth assignment that causes it to evaluate to 1.
A formula with a satisfying assignment is a satisfiable formula. The satisfiability problem
asks whether a given boolean formula is satisfiable; in formal-language terms,
SAT = { φ

: φ is a satisfiable boolean formula}.

As an example, the formula
φ = ((x1 → x2)

¬((¬x1 ↔ x3)

has the satisfying assignment

x4))

¬x2

x1 = 0, x2 = 0, x3 = 1, x4 = 1 , since

