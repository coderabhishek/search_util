Moreover, for each of these algorithms, we can produce a sequence of n input numbers that
causes the algorithm to run in Θ(n lg n) time.
These algorithms share an interesting property: the sorted order they determine is based only
on comparisons between the input elements. We call such sorting algorithms comparison
sorts. All the sorting algorithms introduced thus far are comparison sorts.
In Section 8.1, we shall prove that any comparison sort must make Θ(n lg n) comparisons in
the worst case to sort n elements. Thus, merge sort and heapsort are asymptotically optimal,
and no comparison sort exists that is faster by more than a constant factor.
Sections 8.2, 8.3, and 8.4 examine three sorting algorithms-counting sort, radix sort, and
bucket sort-that run in linear time. Needless to say, these algorithms use operations other than
comparisons to determine the sorted order. Consequently, the Θ(n lg n) lower bound does not
apply to them.

8.1 Lower bounds for sorting
In a comparison sort, we use only comparisons between elements to gain order information
about an input sequence a1, a2, . . ., an . That is, given two elements ai and aj, we perform
one of the tests ai < aj, ai ≤ aj, ai = aj, ai ≥ aj, or ai > aj to determine their relative order. We
may not inspect the values of the elements or gain order information about them in any other
way.
In this section, we assume without loss of generality that all of the input elements are distinct.
Given this assumption, comparisons of the form ai = aj are useless, so we can assume that no
comparisons of this form are made. We also note that the comparisons ai ≤ aj, ai ≥ aj, ai > aj,
and ai < aj are all equivalent in that they yield identical information about the relative order of
ai and aj. We therefore assume that all comparisons have the form ai ≤ aj.
The decision-tree model
Comparison sorts can be viewed abstractly in terms of decision trees. A decision tree is a full
binary tree that represents the comparisons between elements that are performed by a
particular sorting algorithm operating on an input of a given size. Control, data movement,
and all other aspects of the algorithm are ignored. Figure 8.1 shows the decision tree
corresponding to the insertion sort algorithm from Section 2.1 operating on an input sequence
of three elements.

Figure 8.1: The decision tree for insertion sort operating on three elements. An internal node
annotated by i: j indicates a comparison between ai and aj. A leaf annotated by the
permutation π(1), π(2), . . ., π(n) indicates the ordering aπ(1) ≤ aπ(2) ≤ ··· aπ(n). The shaded
path indicates the decisions made when sorting the input sequence a1 = 6, a2 = 8, a3 = 5

