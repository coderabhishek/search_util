Thus we have

The remainder of the proof depends on whether key k is in table T.
•
•

If k ∉ T, then nh(k) = Yk and |{l : l T and l ≠ k}| = n. Thus E[nh(k)] = E[Yk] ≤ n/m = α.
If k T , then because key k appears in list T[h(k)] and the count Yk does not include
key k, we have nh(k) = Yk + 1 and |{l : l T and l ≠ k}| = n - 1. Thus E[nh(k)] = E[Yk] + 1
≤ (n - 1)/m + 1 = 1 + α - 1/m < 1 + α.

The following corollary says universal hashing provides the desired payoff: it is now
impossible for an adversary to pick a sequence of operations that forces the worst-case
running time. By cleverly randomizing the choice of hash function at run time, we guarantee
that every sequence of operations can be handled with good expected running time.
Corollary 11.4
Using universal hashing and collision resolution by chaining in a table with m slots, it takes
expected time Θ(n) to handle any sequence of n INSERT, SEARCH and DELETE operations
containing O(m) INSERT operations.
Proof Since the number of insertions is O(m), we have n = O(m) and so α = O(1). The
INSERT and DELETE operations take constant time and, by Theorem 11.3, the expected time
for each SEARCH operation is O(1). By linearity of expectation, therefore, the expected time
for the entire sequence of operations is O(n).

Designing a universal class of hash functions
It is quite easy to design a universal class of hash functions, as a little number theory will help
us prove. You may wish to consult Chapter 31 first if you are unfamiliar with number theory.

