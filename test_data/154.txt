half-open interval [i/10, (i + 1)/10). The sorted output consists of a concatenation in order of
the lists B[0], B[1], . . ., B[9].
To see that this algorithm works, consider two elements A[i] and A[j]. Assume without loss of
generality that A[i] ≤ A[j]. Since ⌊n A[i]⌋ ⌊n A[j]⌋, element A[i] is placed either into the same
bucket as A[j] or into a bucket with a lower index. If A[i] and A[j] are placed into the same
bucket, then the for loop of lines 4-5 puts them into the proper order. If A[i] and A[j] are
placed into different buckets, then line 6 puts them into the proper order. Therefore, bucket
sort works correctly.
To analyze the running time, observe that all lines except line 5 take O(n) time in the worst
case. It remains to balance the total time taken by the n calls to insertion sort in line 5.
To analyze the cost of the calls to insertion sort, let ni be the random variable denoting the
number of elements placed in bucket B[i]. Since insertion sort runs in quadratic time (see
Section 2.2), the running time of bucket sort is

Taking expectations of both sides and using linearity of expectation, we have
(8.1)

We claim that
(8.2)
for i = 0, 1, . . ., n - 1. It is no surprise that each bucket i has the same value of
, since each
value in the input array A is equally likely to fall in any bucket. To prove equation (8.2), we
define indicator random variables
Xij = I{A[j] falls in bucket i}
for i = 0, 1, . . ., n - 1 and j = 1, 2, . . ., n. Thus,

To compute

, we expand the square and regroup terms:

