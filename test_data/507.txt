If we run Dijkstra's algorithm on a weighted, directed graph G = (V, E) with nonnegative
weight function w and source s, then at termination, the predecessor subgraph GÏ€ is a shortestpaths tree rooted at s.
Proof Immediate from Theorem 24.6 and the predecessor-subgraph property.

Analysis
How fast is Dijkstra's algorithm? It maintains the min-priority queue Q by calling three
priority-queue operations: INSERT (implicit in line 3), EXTRACT-MIN (line 5), and
DECREASE-KEY (implicit in RELAX, which is called in line 8). INSERT is invoked once
per vertex, as is EXTRACT-MIN. Because each vertex v V is added to set S exactly once,
each edge in the adjacency list Adj[v] is examined in the for loop of lines 7-8 exactly once
during the course of the algorithm. Since the total number of edges in all the adjacency lists is
|E|, there are a total of |E| iterations of this for loop, and thus a total of at most |E|
DECREASE-KEY operations. (Observe once again that we are using aggregate analysis.)
The running time of Dijkstra's algorithm depends on how the min-priority queue is
implemented. Consider first the case in which we maintain the min-priority queue by taking
advantage of the vertices being numbered 1 to |V|. We simply store d[v] in the vth entry of an
array. Each INSERT and DECREASE-KEY operation takes O(1) time, and each EXTRACTMIN operation takes O(V) time (since we have to search through the entire array), for a total
time of O(V2+E) = O(V2).
If the graph is sufficiently sparse-in particular, E = o(V2/ lg V)-it is practical to implement the
min-priority queue with a binary min-heap. (As discussed in Section 6.5, an important
implementation detail is that vertices and corresponding heap elements must maintain handles
to each other.) Each EXTRACT-MIN operation then takes time O(lg V). As before, there are
|V| such operations. The time to build the binary min-heap is O(V). Each DECREASE-KEY
operation takes time O(lg V), and there are still at most |E| such operations. The total running
time is therefore O((V + E) lg V), which is O(E lg V) if all vertices are reachable from the
source. This running time is an improvement over the straightforward O(V2)-time
implementation if E = o(V2/ lg V).
We can in fact achieve a running time of O(V lg V + E) by implementing the min-priority
queue with a Fibonacci heap (see Chapter 20). The amortized cost of each of the |V|
EXTRACT-MIN operations is O(lg V), and each DECREASE-KEY call, of which there are at
most |E|, takes only O(1) amortized time. Historically, the development of Fibonacci heaps
was motivated by the observation that in Dijkstra's algorithm there are typically many more
DECREASE-KEY calls than EXTRACT-MIN calls, so any method of reducing the amortized
time of each DECREASE-KEY operation to o(lg V) without increasing the amortized time of
EXTRACT-MIN would yield an asymptotically faster implementation than with binary heaps.
Dijkstra's algorithm bears some similarity to both breadth-first search (see Section 22.2) and
Prim's algorithm for computing minimum spanning trees (see Section 23.2). It is like breadthfirst search in that set S corresponds to the set of black vertices in a breadth-first search; just
as vertices in S have their final shortest-path weights, so do black vertices in a breadth-first

