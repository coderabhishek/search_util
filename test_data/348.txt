Section 17.3 discusses the potential method, which is like the accounting method in that we
determine the amortized cost of each operation and may overcharge operations early on to
compensate for undercharges later. The potential method maintains the credit as the "potential
energy" of the data structure as a whole instead of associating the credit with individual
objects within the data structure.
We shall use two examples to examine these three methods. One is a stack with the additional
operation MULTIPOP, which pops several objects at once. The other is a binary counter that
counts up from 0 by means of the single operation INCREMENT.
While reading this chapter, bear in mind that the charges assigned during an amortized
analysis are for analysis purposes only. They need not and should not appear in the code. If,
for example, a credit is assigned to an object x when using the accounting method, there is no
need to assign an appropriate amount to some attribute credit[x] in the code.
The insight into a particular data structure gained by performing an amortized analysis can
help in optimizing the design. In Section 17.4, for example, we shall use the potential method
to analyze a dynamically expanding and contracting table.

17.1 Aggregate analysis
In aggregate analysis, we show that for all n, a sequence of n operations takes worst-case
time T (n) in total. In the worst case, the average cost, or amortized cost, per operation is
therefore T (n)/n. Note that this amortized cost applies to each operation, even when there are
several types of operations in the sequence. The other two methods we shall study in this
chapter, the accounting method and the potential method, may assign different amortized
costs to different types of operations.
Stack operations
In our first example of aggregate analysis, we analyze stacks that have been augmented with a
new operation. Section 10.1 presented the two fundamental stack operations, each of which
takes O(1) time:
PUSH(S, x) pushes object x onto stack S.
POP(S) pops the top of stack S and returns the popped object.
Since each of these operations runs in O(1) time, let us consider the cost of each to be 1. The
total cost of a sequence of n PUSH and POP operations is therefore n, and the actual running
time for n operations is therefore Θ(n).
Now we add the stack operation MULTIPOP(S,k), which removes the k top objects of stack S,
or pops the entire stack if it contains fewer than k objects. In the following pseudocode, the
operation STACK-EMPTY returns TRUE if there are no objects currently on the stack, and
FALSE otherwise.
MULTIPOP(S, k)
1 while not STACK-EMPTY(S) and k ≠ 0
2
do POP(S)

