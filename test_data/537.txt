Figure 25.4: The sequence of matrices D(k) and Π(k) computed by the Floyd-Warshall
algorithm for the graph in Figure 25.1.
The running time of the Floyd-Warshall algorithm is determined by the triply nested for loops
of lines 3-6. Because each execution of line 6 takes O(1) time, the algorithm runs in time
Θ(n3). As in the final algorithm in Section 25.1, the code is tight, with no elaborate data
structures, and so the constant hidden in the Θ-notation is small. Thus, the Floyd-Warshall
algorithm is quite practical for even moderate-sized input graphs.
Constructing a shortest path
There are a variety of different methods for constructing shortest paths in the Floyd-Warshall
algorithm. One way is to compute the matrix D of shortest-path weights and then construct
the predecessor matrix Π from the D matrix. This method can be implemented to run in O(n3)
time (Exercise 25.1-6). Given the predecessor matrix Π, the PRINT-ALL-PAIRSSHORTEST-PATH procedure can be used to print the vertices on a given shortest path.
We can compute the predecessor matrix Π "on-line" just as the Floyd-Warshall algorithm
computes the matrices D(k). Specifically, we compute a sequence of matrices Π(0), Π(1),..., Π(n),
where Π = Π(n) and is defined to be the predecessor of vertex j on a shortest path from
vertex i with all intermediate vertices in the set {1, 2,..., k}.
We can give a recursive formulation of
intermediate vertices at all. Thus,

. When k = 0, a shortest path from i to j has no

