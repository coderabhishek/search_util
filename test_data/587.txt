right is shown the neighbor list N[y] at the beginning of each iteration, with the iteration
number on top. The shaded neighbor is current[y]. (a) Initially, there are 19 units of excess to
push from y, and current[y] = s. Iterations 1, 2, and 3 just advance current[y], since there are
no admissible edges leaving y. In iteration 4, current[y] = NIL (shown by the shading being
below the neighbor list), and so y is relabeled and current[y] is reset to the head of the
neighbor list. (b) After relabeling, vertex y has height 1. In iterations 5 and 6, edges (y, s) and
(y, x) are found to be inadmissible, but 8 units of excess flow are pushed from y to z in
iteration 7. Because of the push, current[y] is not advanced in this iteration. (c) Because the
push in iteration 7 saturated edge (y, z), it is found inadmissible in iteration 8. In iteration 9,
current[y] = NIL, and so vertex y is again relabeled and current[y] is reset. (d) In iteration 10,
(y, s) is inadmissible, but 5 units of excess flow are pushed from y to x in iteration 11. (e)
Because current[y] was not advanced in iteration 11, iteration 12 finds (y, x) to be
inadmissible. Iteration 13 finds (y, z) inadmissible, and iteration 14 relabels vertex y and resets
current[y]. (f) Iteration 15 pushes 6 units of excess flow from y to s. (g) Vertex y now has no
excess flow, and DISCHARGE terminates. In this example, DISCHARGE both starts and
finishes with the current pointer at the head of the neighbor list, but in general this need not be
the case.
Observe that if DISCHARGE is called on an overflowing vertex u, then the last action
performed by DISCHARGE must be a push from u. Why? The procedure terminates only
when e[u] becomes zero, and neither the relabel operation nor the advancing of the pointer
current[u] affects the value of e[u].
We must be sure that when PUSH or RELABEL is called by DISCHARGE, the operation
applies. The next lemma proves this fact.
Lemma 26.30
If DISCHARGE calls PUSH(u, v) in line 7, then a push operation applies to (u, v). If
DISCHARGE calls RELABEL(u) in line 4, then a relabel operation applies to u.
Proof The tests in lines 1 and 6 ensure that a push operation occurs only if the operation
applies, which proves the first statement in the lemma.
To prove the second statement, according to the test in line 1 and Lemma 26.29, we need only
show that all edges leaving u are inadmissible. Observe that as DISCHARGE(u) is repeatedly
called, the pointer current[u] moves down the list N[u]. Each "pass" begins at the head of
N[u] and finishes with current[u] = NIL, at which point u is relabeled and a new pass begins.
For the current[u] pointer to advance past a vertex v N[u] during a pass, the edge (u, v)
must be deemed inadmissible by the test in line 6. Thus, by the time the pass completes, every
edge leaving u has been determined to be inadmissible at some time during the pass. The key
observation is that at the end of the pass, every edge leaving u is still inadmissible. Why? By
Lemma 26.28, pushes cannot create any admissible edges, let alone one leaving u. Thus, any
admissible edge must be created by a relabel operation. But the vertex u is not relabeled
during the pass, and by Lemma 26.29, any other vertex v that is relabeled during the pass has
no entering admissible edges after relabeling. Thus, at the end of the pass, all edges leaving u
remain inadmissible, and the lemma is proved.

