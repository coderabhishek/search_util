It is not difficult to devise an algorithm that can find both the minimum and the maximum of
n elements using Θ(n) comparisons, which is asymptotically optimal. Simply find the
minimum and maximum independently, using n - 1 comparisons for each, for a total of 2n - 2
comparisons.
In fact, at most 3 ⌊n/2⌋ comparisons are sufficient to find both the minimum and the
maximum. The strategy is to maintain the minimum and maximum elements seen thus far.
Rather than processing each element of the input by comparing it against the current
minimum and maximum, at a cost of 2 comparisons per element, we process elements in
pairs. We compare pairs of elements from the input first with each other, and then we
compare the smaller to the current minimum and the larger to the current maximum, at a cost
of 3 comparisons for every 2 elements.
Setting up initial values for the current minimum and maximum depends on whether n is odd
or even. If n is odd, we set both the minimum and maximum to the value of the first element,
and then we process the rest of the elements in pairs. If n is even, we perform 1 comparison
on the first 2 elements to determine the initial values of the minimum and maximum, and then
process the rest of the elements in pairs as in the case for odd n.
Let us analyze the total number of comparisons. If n is odd, then we perform 3 ⌊n/2⌋
comparisons. If n is even, we perform 1 initial comparison followed by 3(n - 2)/2
comparisons, for a total of 3n/2 - 2. Thus, in either case, the total number of comparisons is at
most 3 ⌊n/2⌋.
Exercises 9.1-1

Show that the second smallest of n elements can be found with n + ⌈lg n⌉ - 2 comparisons in
the worst case. (Hint: Also find the smallest element.)

Exercises 9.1-2: ⋆
Show that ⌈3n/2⌉ - 2 comparisons are necessary in the worst case to find both the maximum
and minimum of n numbers. (Hint: Consider how many numbers are potentially either the
maximum or minimum, and investigate how a comparison affects these counts.)

9.2 Selection in expected linear time
The general selection problem appears more difficult than the simple problem of finding a
minimum. Yet, surprisingly, the asymptotic running time for both problems is the same: Θ(n).
In this section, we present a divide-and-conquer algorithm for the selection problem. The
algorithm RANDOMIZED-SELECT is modeled after the quicksort algorithm of Chapter 7.
As in quicksort, the idea is to partition the input array recursively. But unlike quicksort, which
recursively processes both sides of the partition, RANDOMIZED-SELECT only works on

