objects may appear in any order (subject to our assumption that the first object in each list is
the representative).

Figure 21.2: (a) Linked-list representations of two sets. One contains objects b, c, e, and h,
with c as the representative, and the other contains objects d, f, and g, with f as the
representative. Each object on the list contains a set member, a pointer to the next object on
the list, and a pointer back to the first object on the list, which is the representative. Each list
has pointers head and tail to the first and last objects, respectively. (b) The result of
UNION(e, g). The representative of the resulting set is f.
With this linked-list representation, both MAKE-SET and FIND-SET are easy, requiring O(1)
time. To carry out MAKE-SET(x), we create a new linked list whose only object is x. For
FIND-SET(x), we just return the pointer from x back to the representative.
A simple implementation of union
The simplest implementation of the UNION operation using the linked-list set representation
takes significantly more time than MAKE-SET or FIND-SET. As Figure 21.2(b) shows, we
perform UNION(x, y) by appending x's list onto the end of y's list. We use the tail pointer for
y's list to quickly find where to append x's list. The representative of the new set is the element
that was originally the representative of the set containing y. Unfortunately, we must update
the pointer to the representative for each object originally on x's list, which takes time linear
in the length of x's list.
In fact, it is not difficult to come up with a sequence of m operations on n objects that requires
Θ(n2) time. Suppose that we have objects x1, x2, ..., xn. We execute the sequence of n MAKESET operations followed by n - 1 UNION operations shown in Figure 21.3, so that m = 2n - 1.
We spend Θ(n) time performing the n MAKE-SET operations. Because the ith UNION
operation updates i objects, the total number of objects updated by all n - 1 UNION operations
is

Operation

Number of objects
updated

