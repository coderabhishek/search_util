[5]

This characteristic does not necessarily hold for a resource such as memory. A statement
that references m words of memory and is executed n times does not necessarily consume mn
words of memory in total.

2.3 Designing algorithms
There are many ways to design algorithms. Insertion sort uses an incremental approach:
having sorted the subarray A[1 j - 1], we insert the single element A[j] into its proper place,
yielding the sorted subarray A[1 j].
In this section, we examine an alternative design approach, known as "divide-and-conquer."
We shall use divide-and-conquer to design a sorting algorithm whose worst-case running time
is much less than that of insertion sort. One advantage of divide-and-conquer algorithms is
that their running times are often easily determined using techniques that will be introduced in
Chapter 4.

2.3.1 The divide-and-conquer approach
Many useful algorithms are recursive in structure: to solve a given problem, they call
themselves recursively one or more times to deal with closely related subproblems. These
algorithms typically follow a divide-and-conquer approach: they break the problem into
several subproblems that are similar to the original problem but smaller in size, solve the
subproblems recursively, and then combine these solutions to create a solution to the original
problem.
The divide-and-conquer paradigm involves three steps at each level of the recursion:
•
•
•

Divide the problem into a number of subproblems.
Conquer the subproblems by solving them recursively. If the subproblem sizes are
small enough, however, just solve the subproblems in a straightforward manner.
Combine the solutions to the subproblems into the solution for the original problem.

The merge sort algorithm closely follows the divide-and-conquer paradigm. Intuitively, it
operates as follows.
•
•
•

Divide: Divide the n-element sequence to be sorted into two subsequences of n/2
elements each.
Conquer: Sort the two subsequences recursively using merge sort.
Combine: Merge the two sorted subsequences to produce the sorted answer.

The recursion "bottoms out" when the sequence to be sorted has length 1, in which case there
is no work to be done, since every sequence of length 1 is already in sorted order.
The key operation of the merge sort algorithm is the merging of two sorted sequences in the
"combine" step. To perform the merging, we use an auxiliary procedure MERGE(A, p, q, r),
where A is an array and p, q, and r are indices numbering elements of the array such that p ≤ q
< r. The procedure assumes that the subarrays A[p q] and A[q + 1 r] are in sorted order.
It merges them to form a single sorted subarray that replaces the current subarray A[p r].

