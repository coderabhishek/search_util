We analyze this algorithm in the next section.
Exercises 7.3-1
Why do we analyze the average-case performance of a randomized algorithm and not its
worst-case performance?

Exercises 7.3-2
During the running of the procedure RANDOMIZED-QUICKSORT, how many calls are
made to the random-number generator RANDOM in the worst case? How about in the best
case? Give your answer in terms of Θ-notation.

7.4 Analysis of quicksort
Section 7.2 gave some intuition for the worst-case behavior of quicksort and for why we
expect it to run quickly. In this section, we analyze the behavior of quicksort more rigorously.
We begin with a worst-case analysis, which applies to either QUICKSORT or
RANDOMIZED-QUICKSORT, and conclude with an average-case analysis of
RANDOMIZED-QUICKSORT.

7.4.1 Worst-case analysis
We saw in Section 7.2 that a worst-case split at every level of recursion in quicksort produces
a Θ(n2) running time, which, intuitively, is the worst-case running time of the algorithm. We
now prove this assertion.
Using the substitution method (see Section 4.1), we can show that the running time of
quicksort is O(n2). Let T (n) be the worst-case time for the procedure QUICKSORT on an
input of size n. We have the recurrence
(7.1)
where the parameter q ranges from 0 to n - 1 because the procedure PARTITION produces
two subproblems with total size n - 1. We guess that T (n) ≤ cn2 for some constant c.
Substituting this guess into recurrence (7.1), we obtain

The expression q2 +(n-q-1)2 achieves a maximum over the parameter's range 0 ≤ q ≤ n - 1 at
either endpoint, as can be seen since the second derivative of the expression with respect to q
is positive (see Exercise 7.4-3). This observation gives us the bound max≤q≤n-1(q2+ (n - q - 1)2)
≤ (n - 1)2 = n2 - 2n + 1. Continuing with our bounding of T (n), we obtain

