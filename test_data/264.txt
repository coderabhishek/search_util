•

•

•

Initialization: Prior to the first iteration, line 1 sets r to be the rank of key[x] within
the subtree rooted at x. Setting y ← x in line 2 makes the invariant true the first time
the test in line 3 executes.
Maintenance: At the end of each iteration of the while loop, we set y ← p[y]. Thus
we must show that if r is the rank of key[x] in the subtree rooted at y at the start of the
loop body, then r is the rank of key[x] in the subtree rooted at p[y] at the end of the
loop body. In each iteration of the while loop, we consider the subtree rooted at p[y].
We have already counted the number of nodes in the subtree rooted at node y that
precede x in an inorder walk, so we must add the nodes in the subtree rooted at y's
sibling that precede x in an inorder walk, plus 1 for p[y] if it, too, precedes x. If y is a
left child, then neither p[y] nor any node in p[y]'s right subtree precedes x, so we leave
r alone. Otherwise, y is a right child and all the nodes in p[y]'s left subtree precede x,
as does p[y] itself. Thus, in line 5, we add size[left[p[y]]] + 1 to the current value of r.
Termination: The loop terminates when y = root[T], so that the subtree rooted at y is
the entire tree. Thus, the value of r is the rank of key[x] in the entire tree.

As an example, when we run OS-RANK on the order-statistic tree of Figure 14.1 to find the
rank of the node with key 38, we get the following sequence of values of key[y] and r at the
top of the while loop:
iteration key[y] r
1
2
3
4

38
30
41
26

2
4
4
17

The rank 17 is returned.
Since each iteration of the while loop takes O(1) time, and y goes up one level in the tree with
each iteration, the running time of OS-RANK is at worst proportional to the height of the tree:
O(lg n) on an n-node order-statistic tree.
Maintaining subtree sizes
Given the size field in each node, OS-SELECT and OS-RANK can quickly compute orderstatistic information. But unless these fields can be efficiently maintained by the basic
modifying operations on red-black trees, our work will have been for naught. We shall now
show that subtree sizes can be maintained for both insertion and deletion without affecting the
asymptotic running time of either operation.
We noted in Section 13.3 that insertion into a red-black tree consists of two phases. The first
phase goes down the tree from the root, inserting the new node as a child of an existing node.
The second phase goes up the tree, changing colors and ultimately performing rotations to
maintain the red-black properties.
To maintain the subtree sizes in the first phase, we simply increment size[x] for each node x
on the path traversed from the root down toward the leaves. The new node added gets a size of

