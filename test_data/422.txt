PISANO-DELETE(H, x)
1 if x = min[H]
2
then FIB-HEAP-EXTRACT-MIN(H)
3
else y ← p[x]
4
if y ≠ NIL
5
then CUT(H, x, y)
6
CASCADING-CUT(H, y)
7
add x's child list to the root list of H
8
remove x from the root list of H

a. The professor's claim that this procedure runs faster is based partly on the assumption
that line 7 can be performed in O(1) actual time. What is wrong with this assumption?
b. Give a good upper bound on the actual time of PISANO-DELETE when x is not
min[H]. Your bound should be in terms of degree[x] and the number c of calls to the
CASCADING-CUT procedure.
c. Suppose that we call PISANO-DELETE(H, x), and let H′ be the Fibonacci heap that
results. Assuming that node x is not a root, bound the potential of H′ in terms of
degree[x], c, t(H), and m(H).
d. Conclude that the amortized time for PISANO-DELETE is asymptotically no better
than for FIB-HEAP-DELETE, even when x ≠ min[H].

Problems 20-2: More Fibonacci-heap operations
We wish to augment a Fibonacci heap H to support two new operations without changing the
amortized running time of any other Fibonacci-heap operations.
a. The operation FIB-HEAP-CHANGE-KEY(H, x, k) changes the key of node x to the
value k. Give an efficient implementation of FIB-HEAP-CHANGE-KEY, and analyze
the amortized running time of your implementation for the cases in which k is greater
than, less than, or equal to key[x].
b. Give an efficient implementation of FIB-HEAP-PRUNE(H, r), which deletes min(r,
n[H]) nodes from H. Which nodes are deleted should be arbitrary. Analyze the
amortized running time of your implementation. (Hint: You may need to modify the
data structure and potential function.)

Chapter notes
Fibonacci heaps were introduced by Fredman and Tarjan [98]. Their paper also describes the
application of Fibonacci heaps to the problems of single-source shortest paths, all-pairs
shortest paths, weighted bipartite matching, and the minimum-spanning-tree problem.
Subsequently, Driscoll, Gabow, Shrairman, and Tarjan [81] developed "relaxed heaps" as an
alternative to Fibonacci heaps. There are two varieties of relaxed heaps. One gives the same
amortized time bounds as Fibonacci heaps. The other allows DECREASE-KEY to run in O(1)
worst-case (not amortized) time and EXTRACT-MIN and DELETE to run in O(lg n) worstcase time. Relaxed heaps also have some advantages over Fibonacci heaps in parallel
algorithms.

