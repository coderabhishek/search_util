When edge weights are relatively small nonnegative integers, more efficient algorithms can
be used to solve the single-source shortest-paths problem. The sequence of values returned by
the EXTRACT-MIN calls in Dijkstra's algorithm is monotonically increasing over time. As
discussed in the chapter notes for Chapter 6, in this case there are several data structures that
can implement the various priority-queue operations more efficiently than a binary heap or a
Fibonacci heap. Ahuja, Mehlhorn, Orlin, and Tarjan [8] give an algorithm that runs in
time on graphs with nonnegative edge weights, where W is the largest weight of
any edge in the graph. The best bounds are by Thorup [299], who gives an algorithm that runs
in O(E lg lg V) time, and by Raman, who gives an algorithm that runs in O (E + V min {(lg V)
1/3+
, (lg W)1/4+ }) time. These two algorithms use an amount of space that depends on the
word size of the underlying machine. Although the amount of space used can be unbounded
in the size of the input, it can be reduced to be linear in the size of the input using randomized
hashing.
For undirected graphs with integer weights, Thorup [298] gives an O(V + E)-time algorithm
for single-source shortest paths. In contrast to the algorithms mentioned in the previous
paragraph, this algorithm is not an implementation of Dijkstra's algorithm, since the sequence
of values returned by EXTRACT-MIN calls is not monotonically increasing over time.
For graphs with negative edge weights, an algorithm due to Gabow and Tarjan [104] runs in
time, and one by Goldberg [118] runs in
time, where W = max(u, v) E
{|w(u, v)|}.
Cherkassky, Goldberg, and Radzik [57] conducted extensive experiments comparing various
shortest-path algorithms.

Chapter 25: All-Pairs Shortest Paths
Overview
In this chapter, we consider the problem of finding shortest paths between all pairs of vertices
in a graph. This problem might arise in making a table of distances between all pairs of cities
for a road atlas. As in Chapter 24, we are given a weighted, directed graph G = (V, E) with a
weight function w : E â†’ R that maps edges to real-valued weights. We wish to find, for every
pair of vertices u, v V , a shortest (least-weight) path from u to v, where the weight of a path
is the sum of the weights of its constituent edges. We typically want the output in tabular
form: the entry in u's row and v's column should be the weight of a shortest path from u to v.
We can solve an all-pairs shortest-paths problem by running a single-source shortest-paths
algorithm |V| times, once for each vertex as the source. If all edge weights are nonnegative,
we can use Dijkstra's algorithm. If we use the linear-array implementation of the min-priority
queue, the running time is O(V3 + V E) = O(V3). The binary min-heap implementation of the
min-priority queue yields a running time of O(V E lg V), which is an improvement if the
graph is sparse. Alternatively, we can implement the min-priority queue with a Fibonacci
heap, yielding a running time of O(V2 lg V + V E).
If negative-weight edges are allowed, Dijkstra's algorithm can no longer be used. Instead, we
must run the slower Bellman-Ford algorithm once from each vertex. The resulting running
time is O(V2E), which on a dense graph is O(V4). In this chapter we shall see how to do better.

