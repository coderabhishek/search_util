order bit in A[0] and its highest-order bit in A[k - 1], so that
. Initially, x = 0, and
thus A[i] = 0 for i = 0, 1, ..., k - 1. To add 1 (modulo 2k) to the value in the counter, we use the
following procedure.
INCREMENT(A)
1 i ← 0
2 while i < length[A] and A[i] = 1
3
do A[i] ← 0
4
i ← i + 1
5 if i < length[A]
6
then A[i] ← 1

Figure 17.2 shows what happens to a binary counter as it is incremented 16 times, starting
with the initial value 0 and ending with the value 16. At the start of each iteration of the while
loop in lines 2–4, we wish to add a 1 into position i. If A[i] = 1, then adding 1 flips the bit to 0
in position i and yields a carry of 1, to be added into position i + 1 on the next iteration of the
loop. Otherwise, the loop ends, and then, if i < k, we know that A[i] = 0, so that adding a 1
into position i, flipping the 0 to a 1, is taken care of in line 6. The cost of each INCREMENT
operation is linear in the number of bits flipped.

Figure 17.2: An 8-bit binary counter as its value goes from 0 to 16 by a sequence of 16
INCREMENT operations. Bits that flip to achieve the next value are shaded. The running cost
for flipping bits is shown at the right. Notice that the total cost is never more than twice the
total number of INCREMENT operations.
As with the stack example, a cursory analysis yields a bound that is correct but not tight. A
single execution of INCREMENT takes time Θ(k) in the worst case, in which array A contains
all ′s. Thus, a sequence of n INCREMENT operations on an initially zero counter takes time
O(nk) in the worst case.

