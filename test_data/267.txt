Consider n chords on a circle, each defined by its endpoints. Describe an O(n lg n)-time
algorithm for determining the number of pairs of chords that intersect inside the circle. (For
example, if the n chords are all diameters that meet at the center, then the correct answer is
.) Assume that no two chords share an endpoint.

14.2 How to Augment a Data Structure
The process of augmenting a basic data structure to support additional functionality occurs
quite frequently in algorithm design. It will be used again in the next section to design a data
structure that supports operations on intervals. In this section, we shall examine the steps
involved in such augmentation. We shall also prove a theorem that allows us to augment redblack trees easily in many cases.
Augmenting a data structure can be broken into four steps:
1. choosing an underlying data structure,
2. determining additional information to be maintained in the underlying data structure,
3. verifying that the additional information can be maintained for the basic modifying
operations on the underlying data structure, and
4. developing new operations.
As with any prescriptive design method, you should not blindly follow the steps in the order
given. Most design work contains an element of trial and error, and progress on all steps
usually proceeds in parallel. There is no point, for example, in determining additional
information and developing new operations (steps 2 and 4) if we will not be able to maintain
the additional information efficiently. Nevertheless, this four-step method provides a good
focus for your efforts in augmenting a data structure, and it is also a good way to organize the
documentation of an augmented data structure.
We followed these steps in Section 14.1 to design our order-statistic trees. For step 1, we
chose red-black trees as the underlying data structure. A clue to the suitability of red-black
trees comes from their efficient support of other dynamic-set operations on a total order, such
as MINIMUM, MAXIMUM, SUCCESSOR, and PREDECESSOR.
For step 2, we provided the size field, in which each node x stores the size of the subtree
rooted at x. Generally, the additional information makes operations more efficient. For
example, we could have implemented OS-SELECT and OS-RANK using just the keys stored
in the tree, but they would not have run in O(lg n) time. Sometimes, the additional
information is pointer information rather than data, as in Exercise 14.2-1.
For step 3, we ensured that insertion and deletion could maintain the size fields while still
running in O(lg n) time. Ideally, only a few elements of the data structure should need to be
updated in order to maintain the additional information. For example, if we simply stored in
each node its rank in the tree, the OS-SELECT and OS-RANK procedures would run quickly,
but inserting a new minimum element would cause a change to this information in every node
of the tree. When we store subtree sizes instead, inserting a new element causes information
to change in only O(lg n) nodes.

