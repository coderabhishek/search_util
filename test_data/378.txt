of a subtree and a key k to be searched for in that subtree. The top-level call is thus of the
form B-TREE-SEARCH(root[T], k). If k is in the B-tree, B-TREE-SEARCH returns the
ordered pair (y, i) consisting of a node y and an index i such that keyi[y] = k. Otherwise, the
value NIL is returned.
B-TREE-SEARCH(x, k)
1 i ← 1
2 while i ≤ n[x] and k > keyi[x]
3
do i ← i + 1
4 if i ≤ n[x] and k = keyi[x]
5
then return (x, i)
6 if leaf [x]
7
then return NIL
8
else DISK-READ(ci[x])
9
return B-TREE-SEARCH(ci[x], k)

Using a linear-search procedure, lines 1-3 find the smallest index i such that k ≤ keyi[x], or
else they set i to n[x] + 1. Lines 4-5 check to see if we have now discovered the key, returning
if we have. Lines 6-9 either terminate the search unsuccessfully (if x is a leaf) or recurse to
search the appropriate subtree of x, after performing the necessary DISK-READ on that child.
Figure 18.1 illustrates the operation of B-TREE-SEARCH; the lightly shaded nodes are
examined during a search for the key R.
As in the TREE-SEARCH procedure for binary search trees, the nodes encountered during
the recursion form a path downward from the root of the tree. The number of disk pages
accessed by B-TREE-SEARCH is therefore Θ(h) = Θ(logt n), where h is the height of the Btree and n is the number of keys in the B-tree. Since n[x] < 2t, the time taken by the while
loop of lines 2-3 within each node is O(t), and the total CPU time is O(th) = O(t logt n).
Creating an empty B-tree
To build a B-tree T, we first use B-TREE-CREATE to create an empty root node and then call
B-TREE-INSERT to add new keys. Both of these procedures use an auxiliary procedure
ALLOCATE-NODE, which allocates one disk page to be used as a new node in O(1) time.
We can assume that a node created by ALLOCATE-NODE requires no DISK-READ, since
there is as yet no useful information stored on the disk for that node.
B-TREE-CREATE(T)
1 x ← ALLOCATE-NODE()
2 leaf[x] ← TRUE
3 n[x] ← 0
4 DISK-WRITE(x)
5 root[T] ← x

B-TREE-CREATE requires O(1) disk operations and O(1) CPU time.
Inserting a key into a B-tree
Inserting a key into a B-tree is significantly more complicated than inserting a key into a
binary search tree. As with binary search trees, we search for the leaf position at which to
insert the new key. With a B-tree, however, we cannot simply create a new leaf node and
insert it, as the resulting tree would fail to be a valid B-tree. Instead, we insert the new key

