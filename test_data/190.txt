each operation as efficient as possible. Analyze the running time of each operation in terms of
the size of the dynamic set(s) being operated on.
a. Lists are sorted.
b. Lists are unsorted.
c. Lists are unsorted, and dynamic sets to be merged are disjoint.

Problems 10-3: Searching a sorted compact list
Exercise 10.3-4 asked how we might maintain an n-element list compactly in the first n
positions of an array. We shall assume that all keys are distinct and that the compact list is
also sorted, that is, key[i] < key[next[i]] for all i = 1, 2,..., n such that next[i] ≠ NIL. Under
these assumptions, you will show that the following randomized algorithm can be used to
search the list in
expected time.
COMPACT-LIST-SEARCH(L, n, k)
1 i ← head[L]
2 while i ≠ NIL and key[i] < k
3
do j ← RANDOM(1, n)
4
if key[i] < key[ j] and key[j] ≤ k
5
then i ← j
6
if key[i] = k
7
then return i
8
i ← next[i]
9 if i = NIL or key[i] > k
10
then return NIL
11
else return i

If we ignore lines 3–7 of the procedure, we have an ordinary algorithm for searching a sorted
linked list, in which index i points to each position of the list in turn. The search terminates
once the index i "falls off" the end of the list or once key[i]≥ k. In the latter case, if key[i] = k,
clearly we have found a key with the value k. If, however, key[i] > k, then we will never find a
key with the value k, and so terminating the search was the right thing to do.
Lines 3–7 attempt to skip ahead to a randomly chosen position j. Such a skip is beneficial if
key[j] is larger than key[i] and no larger than k; in such a case, j marks a position in the list
that i would have to reach during an ordinary list search. Because the list is compact, we know
that any choice of j between 1 and n indexes some object in the list rather than a slot on the
free list.
Instead of analyzing the performance of COMPACT-LIST-SEARCH directly, we shall
analyze a related algorithm, COMPACT-LIST-SEARC′, which executes two separate loops.
This algorithm takes an additional parameter t which determines an upper bound on the
number of iterations of the first loop.
COMPACT-LIST-SEARC′ (L, n, k, t)
1 i ← head[L]
2 for q ← 1 to t

