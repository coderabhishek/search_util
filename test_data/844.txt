Figure 34.1: Using a polynomial-time reduction algorithm to solve a decision problem A in
polynomial time, given a polynomial-time decision algorithm for another problem B. In
polynomial time, we transform an instance α of A into an instance β of B, we solve B in
polynomial time, and we use the answer for β as the answer for α.
As long as each of these steps takes polynomial time, all three together do also, and so we
have a way to decide on α in polynomial time. In other words, by "reducing" solving problem
A to solving problem B, we use the "easiness" of B to prove the "easiness" of A.
Recalling that NP-completeness is about showing how hard a problem is rather than how easy
it is, we use polynomial-time reductions in the opposite way to show that a problem is NPcomplete. Let us take the idea a step further, and show how we could use polynomial-time
reductions to show that no polynomial-time algorithm can exist for a particular problem B.
Suppose we have a decision problem A for which we already know that no polynomial-time
algorithm can exist. (Let us not concern ourselves for now with how to find such a problem
A.) Suppose further that we have a polynomial-time reduction transforming instances of A to
instances of B. Now we can use a simple proof by contradiction to show that no polynomialtime algorithm can exist for B. Suppose otherwise, i.e., suppose that B has a polynomial-time
algorithm. Then, using the method shown in Figure 34.1, we would have a way to solve
problem A in polynomial time, which contradicts our assumption that there is no polynomialtime algorithm for A.
For NP-completeness, we cannot assume that there is absolutely no polynomial-time
algorithm for problem A. The proof methodology is similar, however, in that we prove that
problem B is NP-complete on the assumption that problem A is also NP-complete.
A first NP-complete problem

Because the technique of reduction relies on having a problem already known to be NPcomplete in order to prove a different problem NP-complete, we need a "first" NP-complete
problem. The problem we shall use is the circuit-satisfiability problem, in which we are given
a boolean combinational circuit composed of AND, OR, and NOT gates, and we wish to
know whether there is any set of boolean inputs to this circuit that causes its output to be 1.
We shall prove that this first problem is NP-complete in Section 34.3.
Chapter outline
This chapter studies the aspects of NP-completeness that bear most directly on the analysis of
algorithms. In Section 34.1, we formalize our notion of "problem" and define the complexity
class P of polynomial-time solvable decision problems. We also see how these notions fit into
the framework of formal-language theory. Section 34.2 defines the class NP of decision
problems whose solutions can be verified in polynomial time. It also formally poses the P ≠
NP question.
Section 34.3 shows how relationships between problems can be studied via polynomial-time
"reductions." It defines NP-completeness and sketches a proof that one problem, called
"circuit satisfiability," is NP-complete. Having found one NP-complete problem, we show in

