Such a shift s′ is the first shift greater than s that is not necessarily invalid due to our
knowledge of T[s + 1 s + q]. In the best case, we have that s′ = s + q, and shifts s + 1, s + 2,
. . . , s + q - 1 are all immediately ruled out. In any case, at the new shift s′ we don't need to
compare the first k characters of P with the corresponding characters of T, since we are
guaranteed that they match by equation (32.5).
The necessary information can be precomputed by comparing the pattern against itself, as
illustrated in Figure 32.10(c). Since T[s′ + 1 s′ + k] is part of the known portion of the text,
it is a suffix of the string Pq. Equation (32.5) can therefore be interpreted as asking for the
largest k < q such that Pk ⊐ Pq. Then, s′ = s+(q - k) is the next potentially valid shift. It turns
out to be convenient to store the number k of matching characters at the new shift s′, rather
than storing, say, s′ - s. This information can be used to speed up both the naive stringmatching algorithm and the finite-automaton matcher.
We formalize the precomputation required as follows. Given a pattern P[1 m], the prefix
function for the pattern P is the function π : {1, 2, . . . , m} → {0, 1, . . . , m - 1} such that
π[q] = max {k : k < q and Pk ⊐ Pq}.
That is, π[q] is the length of the longest prefix of P that is a proper suffix of Pq. As another
example, Figure 32.11(a) gives the complete prefix function π for the pattern ababababca.

Figure 32.11: An illustration of Lemma 32.5 for the pattern P = ababababca and q = 8. (a)
The π function for the given pattern. Since π[8] = 6, π[6] = 4, π[4] = 2, and π[2] = 0, by
iterating π we obtain π*[8] = {6, 4, 2, 0}. (b) We slide the template containing the pattern P to
the right and note when some prefix Pk of P matches up with some proper suffix of P8; this
happens for k = 6, 4, 2, and 0. In the figure, the first row gives P, and the dotted vertical line is
drawn just after P8. Successive rows show all the shifts of P that cause some prefix Pk of P to
match some suffix of P8. Successfully matched characters are shown shaded. Vertical lines
connect aligned matching characters. Thus, {k : k < q and Pk ⊐ Pq} = {6, 4,2, 0}. The lemma
claims that π*[q] = {k : k < q and Pk ⊐ Pq} for all q.
The Knuth-Morris-Pratt matching algorithm is given in pseudocode below as the procedure
KMP-MATCHER. It is mostly modeled after FINITE-AUTOMATON-MATCHER, as we

