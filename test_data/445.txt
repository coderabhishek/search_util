shortest paths from a given source vertex to all other vertices, and Chapter 25 considers the
computation of shortest paths between every pair of vertices.
Finally, Chapter 26 shows how to compute a maximum flow of material in a network
(directed graph) having a specified source of material, a specified sink, and specified
capacities for the amount of material that can traverse each directed edge. This general
problem arises in many forms, and a good algorithm for computing maximum flows can be
used to solve a variety of related problems efficiently.
In describing the running time of a graph algorithm on a given graph G = (V, E), we usually
measure the size of the input in terms of the number of vertices |V| and the number of edges
|E| of the graph. That is, there are two relevant parameters describing the size of the input, not
just one. We adopt a common notational convention for these parameters. Inside asymptotic
notation (such as O-notation or Î˜-notation), and only inside such notation, the symbol V
denotes |V| and the symbol E denotes |E|. For example, we might say, "the algorithm runs in
time O(V E)," meaning that the algorithm runs in time O(|V||E|). This convention makes the
running-time formulas easier to read, without risk of ambiguity.
Another convention we adopt appears in pseudocode. We denote the vertex set of a graph G
by V [G] and its edge set by E[G]. That is, the pseudocode views vertex and edge sets as
attributes of a graph.

Chapter 22: Elementary Graph Algorithms
This chapter presents methods for representing a graph and for searching a graph. Searching a
graph means systematically following the edges of the graph so as to visit the vertices of the
graph. A graph-searching algorithm can discover much about the structure of a graph. Many
algorithms begin by searching their input graph to obtain this structural information. Other
graph algorithms are organized as simple elaborations of basic graph-searching algorithms.
Techniques for searching a graph are at the heart of the field of graph algorithms.
Section 22.1 discusses the two most common computational representations of graphs: as
adjacency lists and as adjacency matrices. Section 22.2 presents a simple graph-searching
algorithm called breadth-first search and shows how to create a breadth-first tree. Section 22.3
presents depth-first search and proves some standard results about the order in which depthfirst search visits vertices. Section 22.4 provides our first real application of depth-first search:
topologically sorting a directed acyclic graph. A second application of depth-first search,
finding the strongly connected components of a directed graph, is given in Section 22.5.

22.1 Representations of graphs
There are two standard ways to represent a graph G = (V, E): as a collection of adjacency lists
or as an adjacency matrix. Either way is applicable to both directed and undirected graphs.
The adjacency-list representation is usually preferred, because it provides a compact way to
represent sparse graphs-those for which |E| is much less than |V|2. Most of the graph
algorithms presented in this book assume that an input graph is represented in adjacency-list
form. An adjacency-matrix representation may be preferred, however, when the graph is
dense-|E| is close to |V|2-or when we need to be able to tell quickly if there is an edge

