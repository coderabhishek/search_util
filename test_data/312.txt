Figure 15.9: Seven points in the plane, shown on a unit grid. (a) The shortest closed tour, with
length approximately 24.89. This tour is not bitonic. (b) The shortest bitonic tour for the same
set of points. Its length is approximately 25.58.
J. L. Bentley has suggested that we simplify the problem by restricting our attention to bitonic
tours, that is, tours that start at the leftmost point, go strictly left to right to the rightmost
point, and then go strictly right to left back to the starting point. Figure 15.9(b) shows the
shortest bitonic tour of the same 7 points. In this case, a polynomial-time algorithm is
possible.
Describe an O(n2)-time algorithm for determining an optimal bitonic tour. You may assume
that no two points have the same x-coordinate. (Hint: Scan left to right, maintaining optimal
possibilities for the two parts of the tour.)

Problems 15-2: Printing neatly
Consider the problem of neatly printing a paragraph on a printer. The input text is a sequence
of n words of lengths l1, l2, ..., ln, measured in characters. We want to print this paragraph
neatly on a number of lines that hold a maximum of M characters each. Our criterion of
"neatness" is as follows. If a given line contains words i through j, where i ≤ j, and we leave
exactly one space between words, the number of extra space characters at the end of the line
is
, which must be nonnegative so that the words fit on the line. We wish to
minimize the sum, over all lines except the last, of the cubes of the numbers of extra space
characters at the ends of lines. Give a dynamic-programming algorithm to print a paragraph of
n words neatly on a printer. Analyze the running time and space requirements of your
algorithm.

Problems 15-3: Edit distance
In order to transform one source string of text x[1 m] to a target string y[1 n], we can
perform various transformation operations. Our goal is, given x and y, to produce a series of
transformations that change x to y. We use an array z—assumed to be large enough to hold all
the characters it will need—to hold the intermediate results. Initially, z is empty, and at
termination, we should have z[j] = y[j] for j = 1, 2, ..., n. We maintain current indices i into x
and j into z, and the operations are allowed to alter z and these indices. Initially, i = j = 1. We
are required to examine every character in x during the transformation, which means that at
the end of the sequence of transformation operations, we must have i = m + 1.

