determine whether a set of line segments contains any intersections. Two clever algorithms
for finding the convex hull of a set of points-Graham's scan and Jarvis's march-also illustrate
the power of sweeping methods. The chapter closes with an efficient algorithm for finding the
closest pair from among a given set of points in the plane.
Chapter 34 concerns NP-complete problems. Many interesting computational problems are
NP-complete, but no polynomial-time algorithm is known for solving any of them. This
chapter presents techniques for determining when a problem is NP-complete. Several classic
problems are proved to be NP-complete: determining if a graph has a hamiltonian cycle,
determining if a boolean formula is satisfiable, and determining if a given set of numbers has
a subset that adds up to a given target value. The chapter also proves that the famous
traveling-salesman problem is NP-complete.
Chapter 35 shows how approximation algorithms can be used to find approximate solutions to
NP-complete problems efficiently. For some NP-complete problems, approximate solutions
that are near optimal are quite easy to produce, but for others even the best approximation
algorithms known work progressively more poorly as the problem size increases. Then, there
are some problems for which one can invest increasing amounts of computation time in return
for increasingly better approximate solutions. This chapter illustrates these possibilities with
the vertex-cover problem (unweighted and weighted versions), an optimization version of 3CNF satisfiability, the traveling-salesman problem, the set-covering problem, and the subsetsum problem.

Chapter 27: Sorting Networks
Overview
In Part II, we examined sorting algorithms for serial computers (random-access machines, or
RAM's) that allow only one operation to be executed at a time. In this chapter, we investigate
sorting algorithms based on a comparison-network model of computation, in which many
comparison operations can be performed simultaneously.
Comparison networks differ from RAM's in two important respects. First, they can only
perform comparisons. Thus, an algorithm such as counting sort (see Section 8.2) cannot be
implemented on a comparison network. Second, unlike the RAM model, in which operations
occur serially-that is, one after another-operations in a comparison network may occur at the
same time, or "in parallel." As we shall see, this characteristic allows the construction of
comparison networks that sort n values in sublinear time.
We begin in Section 27.1 by defining comparison networks and sorting networks. We also
give a natural definition for the "running time" of a comparison network in terms of the depth
of the network. Section 27.2 proves the "zero-one principle," which greatly eases the task of
analyzing the correctness of sorting networks.
The efficient sorting network that we shall design is essentially a parallel version of the
merge-sort algorithm from Section 2.3.1. Our construction will have three steps. Section 27.3
presents the design of a "bitonic" sorter that will be our basic building block. We modify the
bitonic sorter slightly in Section 27.4 to produce a merging network that can merge two sorted

