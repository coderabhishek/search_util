The circuit C = f(x) that F computes is obtained by modifying C′ slightly. First, the inputs to
C′ corresponding to the program for A, the initial program counter, the input x, and the initial
state of memory are wired directly to these known values. Thus, the only remaining inputs to
the circuit correspond to the certificate y. Second, all outputs to the circuit are ignored, except
the one bit of cT(n) corresponding to the output of A. This circuit C, so constructed, computes
C(y) = A(x, y) for any input y of length O(nk). The reduction algorithm F, when provided an
input string x, computes such a circuit C and outputs it.
Two properties remain to be proved. First, we must show that F correctly computes a
reduction function f . That is, we must show that C is satisfiable if and only if there exists a
certificate y such that A(x, y) = 1. Second, we must show that F runs in polynomial time.
To show that F correctly computes a reduction function, let us suppose that there exists a
certificate y of length O(nk) such that A(x, y) = 1. Then, if we apply the bits of y to the inputs
of C, the output of C is C(y) = A(x, y) = 1. Thus, if a certificate exists, then C is satisfiable.
For the other direction, suppose that C is satisfiable. Hence, there exists an input y to C such
that C(y) = 1, from which we conclude that A(x, y) = 1. Thus, F correctly computes a
reduction function.
To complete the proof sketch, we need only show that F runs in time polynomial in n = |x|.
The first observation we make is that the number of bits required to represent a configuration
is polynomial in n. The program for A itself has constant size, independent of the length of its
input x. The length of the input x is n, and the length of the certificate y is O(nk). Since the
algorithm runs for at most O(nk) steps, the amount of working storage required by A is
polynomial in n as well. (We assume that this memory is contiguous; Exercise 34.3-5 asks
you to extend the argument to the situation in which the locations accessed by A are scattered
across a much larger region of memory and the particular pattern of scattering can differ for
each input x.)
The combinational circuit M implementing the computer hardware has size polynomial in the
length of a configuration, which is polynomial in O(nk) and hence is polynomial in n. (Most of
this circuitry implements the logic of the memory system.) The circuit C consists of at most t
= O(nk) copies of M, and hence it has size polynomial in n. The construction of C from x can
be accomplished in polynomial time by the reduction algorithm F, since each step of the
construction takes polynomial time.

The language CIRCUIT-SAT is therefore at least as hard as any language in NP, and since it
belongs to NP, it is NP-complete.
Theorem 34.7
The circuit-satisfiability problem is NP-complete.
Proof Immediate from Lemmas 34.5 and 34.6 and from the definition of NP-completeness.

